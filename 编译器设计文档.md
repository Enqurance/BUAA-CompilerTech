# 编译器设计文档

## 一、参考编译器介绍

​		本人主要参考了课程组提供的PL0编译器和Pascal-S编译器，同时参考了哈工大编译原理的MOOC课程进行编译器的设计。

### PL0编译器

​		PL0语言是Pascal语言的子集，该编译器生产代码为PCode，且思想较为简单，便于新手阅读理解、提取关键思想。其程序大致分为词法分析、语法分析、错误处理、代码生成等。该编译器的精华在于词法分析、语法分析和错误处理。

​		PL0看上去应当是一个追求在一边扫描就结束编译过程的编译器，尽管是高效的，但是对于要分步骤完成编译大作业的同学们来说，不推荐这种方法，最好还是解耦完成，保证正确性。

​		PL0的词法分析程序是getsym，通过使用getch读取最小元（Token），然后向送入词法分析程序进行解析。此处的难点是对空白符号的处理和对长字符串的循环读入处理，该编译器通过封装读取各种Token对应的字符的过程实现了较好的程序结构化，同时对换行、空白符也设置了处理过程。当然，该过程是边读入文件边进行分析的，或许这一点还需要优化。

​		语法分析使用多个过程构成了从左到右递归下降的分析程序，对于每个产生式，将分析部分和错误处理糅合在一起，一部分错误在此阶段就可以被直接发现，符合预期中的递归下降子程序结构，这一点值得参考。不过其过程中揉进了词法分析、语法分析、填写符号表等一系列操作，且Pascal语言读起来十分不习惯，故而我认为除了结构可以参考外就没有太多的价值了。

​		总的来讲，PL0编译器为语法分析和词法分析提供了很好的思路。我们可以想办法对其原有的结构进行解构，而参考其部分过程的书写方式，使其既能适应大作业的开发，又可以在细节上保持正确。

## 二、 编译器总体设计

### 1.文件组织结构及类介绍

​		Java文件的组织结构能在一定程度上体现我在某一阶段的设计思想。

​		举出src文件下的文件树：

```shell
├── ClassFile
│   ├── ......
├── Tool
│   ├── ......
└── Compiler.java
```

​		ClassFile是用于存放枚举类和对象类的，枚举类都存放了可供全局访问的、易于理解的静态变量以及访问接口，对象类提供了存储单元。这以便于将繁琐而有需要长期访问的固定数据和主程序剖离，降低耦合度。例如，我用CategoryCode类存放了类别码，并提供了查询接口；用TokenType类划分了Token的类型，并提供了识别Token类型的接口；Token类为每一个语法分析单元提供了可实例化的对象，在提高信息存储能力的同时增加了代码的可扩展性。

​		Tool用于存放工具类，包括Lexer、Parser等，这部分是编译器的动态程序。

​		Compiler是编译器的入口程序，不用过多介绍。

### 2.

##   三、词法分析设计

### 编码前设计：

​		词法分析主要由Lexer来完成。在参考了其他编译器的设计以及阅读了实验手册后，我放弃了使用有限自动机设计词法分析器的方法，而采取了参考手册给出的**方案3**。词法分析是一个线性过程，而所给的Sysy文法也不是很复杂，方案三的**分类+扫描**的设计思维和我的设计思维较为吻合。尤其需要注意的是我们时刻需要维护一个当前扫描到的符号的指针，和一个当前符号所处行数的int类型变量，以便于我们对词法分析过程进行检查和为以后的设计预留接口。

​		此处，需要设计Token类来存放Token，存储Token的相关信息，以便于后面语法分析阶段构造语法树和生成代码时建立符号表（目前可以想到的需要存放的信息较少，以后会增加）；同时需要构造一个枚举类用于方便地查取类别码，配置访问接口（Pascal-S编译器用宏定义来解决这个问题，但面向对象给我们提供了代码可读性更高的解决方法）。

### 完成编码：

​		词法分析器Lexer的具体实现和设计时构想的思路基本一致，没有遇到特别大的困难，官方评测和辅助样例库也都是一次通过，显得相当顺利。下面介绍一些实现上的具体细节。

#### **读入**

​		一开始，我尚不是很了解Java的String类型存储的方法，以为换行符、空白符会影响到计数和判断（当然，我在学习C语言的时候就应该知道这是杞人忧天），所以想要实现一个边读入边分析（一次读入一行）的词法分析器。但是考虑到这样会导致功能的高耦合，很不利于Debug，于是我和师兄沟通交流，最后决定采取将所有文件读入为一个长串进行分析，在文件的换行处插入换行符。这虽然是一个很细小的细节，但你的词法分析方法可能长达几百行，如果在这个函数中糅合乱七八糟的功能，很可能会出现问题。

<img src="/Users/enqurance/Desktop/BUAA/大三上/编译/Complier/DocPics/Lexer1.png" alt="Lexer1" style="zoom: 25%;" />

#### Token的识别

​		具体到识别的阶段，Token的识别还可以细分为好几类。针对每一类制定具体的识别方案有助于我们验证自己识别方法的正确性并加快编码的速度、提高代码复用率。

- 读入一个字符即可识别Token类型。这其中包括+、-、*、（等简单符号。这类符号很好识别，只要读入就可以认为获得了一个Token
- 前缀同型类。这类Token的前面几个字符可能相同，如==、>=、//、等，需要在读入的时候顺便看一眼下一个字符，以正确判断到底遇到了何种Token
- 循环终止类。这类Token需要我们使用while循环不断向前看字符，直至到达该类字符的终止条件，包括/**/、空白字符等。与此同时，要注意遇到这些字符的时候很大概率会遇到换行，需要维护行数计数器

​		第一类Token的识别很简单，几乎不用考虑什么；第二三类Token的识别需要有一些技巧，并且要防止越界情况的发生。

#### 枚举类

​		CategoryCode是我建立的一个枚举类，这个类用于存放和查询Token的类别码，这个主意也是和别人讨论想出来的，其目的也是为了降低代码耦合度。除了使用public static修饰的String来提供外部访问功能外，还建立了一个HashMap用于映射具体字符到类别码的HashMap。这一部分的代码是手敲的，没有什么难度，只要不打错字即可。

### 词法分析总结：

​		总的来讲，词法分析器设计起来没有什么难度，麻烦的只是一直在做一些重复的工作、关注一些琐碎的细节。当然，逐步提高难度令同学们逐渐适应增量开发的过程，我想这是课程组精心考虑过的。

## 四、语法分析设计

​		由于在大二下学期参加过OO课程，我对递归下降的分析过程有了初步的感知。但在参加理论课程后才发现，相比我当时自己写的"递归下降"，真正的递归下降是很规范化的（怪不得我当时写了这么多Bug）。在本阶段，我也打算采取递归下降的分析方法实现语法分析设计。很显然，在我的设计中语法分析器Parser是独立于词法器的；而有的同学可能将这两个过程设计在一起。

### 编码前设计

​		我在这一阶段的设想分为两步：

- 先构造一个标准、纯净的递归下降的过程，仅仅使用数组对递归下降的结果进行顺序保存。这一步主要是为了保证程序的正确性，确保评测的分数
- 在第一步的基础上，向递归下降分析过程中添加构造语法树的代码，为后续的开发提供便利

​		我认为，构造递归下降的过程总体上是一个机械化的过程，不难实现；且经过理论课的学习后，发现这种分析法具有很好的可扩展性（如可以升级成语法制导翻译等）。所以我打算将这一部分拆成两步完成。

#### 1.Parser的基本结构

​		和Lexer一样，仍是建立一个Parser类并使用一个对象来完成递归下降。由于我们在词法分析中已经获取了进行语法识别的最小单元（Token），我们可以直接从Lexer拿去Tokens数组进行分析。

​		首先要明确的是在递归下降的过程中，我们按照文法进行分析，每遇到一个终结符号，都代表着这个Token已经被识别了，可以进行下一个Token的识别。于是我认为需要维护一个private的int属性来标记当前识别到的Token在Tokens数组中的下标（另有他用）；维护一个private的Token属性指向当前对应的Token。通过维护这两个属性，可以实现在递归下降过程中识别到终结符后的"向前移动"。

​		其次，对于每一个非终结符，可以编写一个规范化的函数对其进行分析识别：

```java
public void A(){
  	if(...){
    		getToken();
  	} else {
    		error();
  	}
  	...
		B();
  	...
  	addNote();
}
```

​		按照产生式的顺序，遇到终结符使用条件语句进行判断，识别正确的情况下拿取下一个Token；遇到非终结符要调用递归下降的子程序；在某个非终结符分析函数的结尾，需要将该非终结符加入分析队列中以便于输出。由于递归下降是从左向右分析的，保存到数组中的分析结果一定满足输出要求。按照这样的思路，我们可以设计所有非终结符的递归下降函数并将其组合。

#### 2.向前看的策略与First集

​		一个产生式的候选式可能有多个，机器没有人的智能，可以灵活地选择。倘若遇到"路径分叉"，机器可能（仅仅是可能）无法从当前的符号直接判断出正确的路径，故而我们需要为机器制定策略。回退的方法不仅效率低，且难以实现，故而我选择了**向前看**的策略，通过预读Token来进行候选式的选择。这一策略需要我们在分析非终结符的First集的基础上不断向后观察。我们举一个例子来说明：

```C
CompUnit → {Decl} {FuncDef} MainFuncDef
/* 列出First集 */
Decl 				{'const', 'int'}	
FuncDef 		{'void', 'int'}
MainFuncDef {'int'}
First集不足以区分
Token为'const'则选择Decl递归下降，'void'则选择FuncDef递归下降，'int'则需要向前看
Decl 'const' | 'int'Ident'[' | 'int'Ident'=' | 'int'Ident','
FuncDef ('void' | 'int')Ident'('
MainFuncDef 'int''main'
```

​		这是比较复杂的情况，首先列出候选式的First集。当我们对CompUnit进行语法分析的时候，如果读到的第一个Token是const或者是void，相应地可以直接选择进入Decl和FuncDef继续语法分析；但倘若读到int，那么就需要预读Token。如果int后面紧跟的Token是main，那么可以直接选择MainFuncDef进行分析；如果是Ident，很遗憾我们还无法区别Decl和FuncDef，需要再读一个Token才能判断。为了分析全面，我们可能需要反复检查并且分析多条产生式，稍有不慎就可能遗漏——这就是这种简单解决方法的代价。上文提到的指向当前Token的int属性便于我们这么操作，直接将其加上常数即可。

​		另外提一句，这一部分看起来分析的很细致，然而我认为边做边分析是更优的，这有助于我们深入理解和查漏补缺。

#### 3.可选的语法单元与可多次出现的语法单元

​		用中括号扩起来的语法单元是可有可无的，用花括号括起来的语法单元是可以多次出现的。对于这一部分语法单元，需要编写特殊的程序结构来处理。可选的语法单元需要分支结构来支持，同时要注意分析时**如果没有出现一个可选语法单元First集中的Token，并不能直接报错**。多次出现的语法单元需要用while循环进行识别，根据其First集的特点搭建识别循环并不复杂。

#### 4.消除左递归

​		这个问题听起来吓人，跟别人交流之后，发现其实也没啥。使用递归下降分析文法，必须改写文法消除左递归，但这可能会导致我们的编译器输出的输出序列和官方输出序列不一致。不过将左递归产生时改写为扩充的BNF文法并使用while语句进行分析，在分析的时候额外添加代码补充语法成分应该不难解决这个问题。

#### 5.构建语法树

​		这一部分可能会放到错误处理部分进行介绍。

### 完成编码：

​		编码思路和设计思路基本一致，只是遇到了遗漏First集元素、输出序列顺序不符合要求的问题。递归下降的编写思路很简单，但是想要不遗漏First集很难，毕竟产生式还是比较多的，需要便分析产生时边将分析结果记录下来：

```C
CompUnit → {Decl} {FuncDef} MainFuncDef
Decl 				{'const', 'int'}
FuncDef 		{'void', 'int'}
MainFuncDef {'int'}
First集不足以区分
Token为'const'则选择Decl递归下降，'void'则选择FuncDef递归下降，'int'则需要向前看
Decl 'const' | 'int'Ident'[' | 'int'Ident'=' | 'int'Ident','
FuncDef ('void' | 'int')Ident'('
MainFuncDef 'int''main'
  
Decl → ConstDecl | VarDecl
ConstDecl		{'const'}
VarDecl			{'int'}
First集足以区分，直接选择即可
ConstDecl		'const'
VarDecl			'int'
  
FuncDef → FuncType Ident '(' [FuncFParams] ')' Block
FuncFParams = {'int'}
该产生式开头无需选择，直接线性分析即可。FuncFParams需要选择
FuncFParams 	'int'

MainFuncDef → 'int' 'main' '(' ')' Block
不需要对这个产生式做任何处理
  
ConstDecl → 'const' BType ConstDef { ',' ConstDef } ';'
需要考虑可能有多个ConstDef的情况，但不需要考虑First集的问题
  
VarDecl → BType VarDef { ',' VarDef } ';'
和ConstDecl类似，需要考虑多个VarDef的情况
  
FuncFParams → FuncFParam { ',' FuncFParam }
不需要考虑First集合，需要考虑多个FuncFParam
  
Block → '{' { BlockItem } '}'
需要考虑BlockItem的First集

BlockItem → Decl | Stmt
需要考虑Decl和Stmt的First集
  
ConstDef → Ident { '[' ConstExp ']' } '=' ConstInitVal
需要考虑多个ConstExp的情况，直接判断'['的存在性即可
  
FuncFParam → BType Ident ['[' ']' { '[' ConstExp ']' }]
需要考虑存在数组参数的情况
  
BlockItem → Decl | Stmt
需要考虑Decl和Stmt的First集
Decl			{'const', 'int'}
Stmt			{
  Lval		{'Ident'},
  [Exp]→UnaryExp	{
    	PrimaryExp			{'(', 'Ident', 'IntConst'},
    	----------			{'Ident'},
    	UnaryOp					{'+', '-', '!'},
  },
  ';'
  Block		{'{'},
  'if', 'while', 'break', 'continue', 'return', 'printf', 'Ident'
}

ConstExp → AddExp
直接调用即可
  
ConstInitVal → ConstExp | '{' [ ConstInitVal { ',' ConstInitVal } ] '}'
考虑两个候选式的First集，以及多个ConstInitVal的情况
-----			{'{'}
ConstExp	{和UnaryExp相同，不存在冲突}

InitVal → Exp | '{' [ InitVal { ',' InitVal } ] '}'
需要考虑Exp的First集和多个InitVal的情况
-----			{'{'}
Exp				{和UnaryExp相同，不存在冲突}

Stmt → LVal '=' Exp ';' | 
  		[Exp] ';' | 
  		Block | 
  		'if' '(' Cond ')' Stmt [ 'else' Stmt ] | 
  		'while' '(' Cond ')' Stmt |
  		'break' ';' |
  		'continue' ';' |
  		'return' [Exp] ';' |
  		LVal '=' 'getint''('')'';' | 
  		'printf''('FormatString{','Exp}')'';'
感谢指导书！提供了一种非常便利的解决思路，就是从当前字符向后看，先看到';'则选择表达式，否则先看到'='就选择赋值语句。如果只从First集来看，在处理LVal候选式和Exp候选式的选择时，需要仔细计算。指导书的方法非常不错，让我们偷了一次懒。这个方法比较庞大，需要认真维护。
  
Cond → LOrExp
一个直接调用的产生式
  
LVal → Ident {'[' Exp ']'}
需要考虑多个Exp的情况
  
AddExp → MulExp | AddExp ('+' | '−') MulExp
这是一个左递归产生式，首先需要对其进行改写（必须消除左递归）
AddExp → MulExp {('+' | '-') MulExp}
然而对于形如A+B-C+D的式子，原来的产生式是能够构造一棵四层的语法树的，并且可以输出四个AddExp；显然改写后的文法不具备这样的特征，我们需要在代码使用另外的方法实现题目的要求。可以选择"打包建树"的方法，额外添加AddExp来维护语法树。
  
LOrExp → LAndExp | LOrExp '||' LAndExp
这也是一个左递归产生式，同样要对它进行改写
LOrExp → LAndExp {'||' LOrExp}
处理方法和上面的左递归产生式相同
  
MulExp → UnaryExp | MulExp ('*' | '/' | '%') UnaryExp
这也是一个令人困扰的左递归产生式，首先进行改写
MulExp → UnaryExp {('*' | '/' | '%') UnaryExp}

LAndExp → EqExp | LAndExp '&&' EqExp
All the same!
LAndExp → EqExp {'&&' EqExp}

一元表达式 UnaryExp → PrimaryExp | Ident '(' [FuncRParams] ')' | UnaryOp UnaryExp
需要考察First集
PrimaryExp		{'(', 'Ident', 'IntConst'}
-----					{'Ident'}
UnaryOp 			{'+' | '−' | '!'}
UnaryOp这一产生式可以直接通过阅读当前的Token做出选择，但PrimaryExp的部分情况需要向后看来进行扫描。倘若遇到Ident，则需要向前看一个Token，若遇到'('则可选择第二个候选式，否则选择PrimaryExp候选式。
  
EqExp → RelExp | EqExp ('==' | '!=') RelExp
左递归产生式
EqExp →RelExp {('==' | '!=') RelExp}

PrimaryExp → '(' Exp ')' | LVal | Number
考察First集，选择产生式
-----					{'('}
LVal					{'Ident'}
Number				{'IntConst'}
非常好判断
  
UnaryOp → '+' | '−' | '!'
直接根据Token选择即可
  
FuncRParams → Exp { ',' Exp }
注意多个Exp的情况
  
RelExp → AddExp | RelExp ('<' | '>' | '<=' | '>=') AddExp
左递归产生式，改写
RelExp → AddExp {('<' | '>' | '<=' | '>=') AddExp}

Number → IntConst
直接判断Token即可
```

​		工程量比较大，debug也比较困难。于是我也借助辅助库的样例构建了Python自动评测机，并且代码在能够通过所有辅助库样例的情况下一定可以通过作业评测。![AutoTest](/Users/enqurance/Desktop/BUAA/大三上/编译/Complier/DocPics/AutoTest.jpeg)

​		另外，我看到有的同学为每一个非终结符都设计了一个类用于保存其分析成分，我认为这是可取的做法，不过并不会采用，建立这么多类实在是太麻烦了。当然，我以后还可能会对两种做法再次作出评价。

## 五、错误处理

​		根据理论课知识，可能出现的错误主要分为两类：语法错误和语义错误。语法错误是出现在语法分析当中的，是因为在按照规则进行递归下时读到了不符合预期的单词；语义错误则是在语法分析成功后才能被发现的，需要分析语法成分的信息才能得出。为了处理可能出现的错误，需要建立符号表。

## 六、中间代码生成

​		中间代码生成是生成目标代码的前一部分。对于编译器，如果目标代码的使用规范过多、使用方法过于复杂，直接生成目标代码是不好的，将会导致编译器的耦合度过高。一种可行的办法是生成一套简单但功能完备的中间代码，作为编译器和目标机之间的"协议"。我选择MIPS作为需要生成的目标代码，MIPS目标代码较为复杂，生成中间代码这一步是需要精心设计的。

​		首先需要明确，中间代码生成的基本方法仍是按照文法遍历语法树和操作符号表。**使用语法制导翻译，为解析的某些步骤设计语义动作或者是属性，从而让编译器可以输出符合中间代码表达要求的一定信息，根据这些输出信息来构造中间代码。**

​		为了存储并输出中间代码，我们需要设计一些存储单元来存储中间代码的相关信息。根据课程组的规范，中间代码包括了声明、计算、调用等一系列不同种类的语句，能观察到的是不同种类之间的形式差别较大，故而可以设计一系列子类来表达不同的中间代码。

### 中间代码设计

​		中间代码的设计主要依照课程组所给的文档进行。

|    种类    |               表达                |
| :--------: | :-------------------------------: |
|   ICode    |              Father               |
|    Exp     |    `res` = `sym1` `op` `sym2`     |
|  FuncDecl  |  `FuncType` `FuncName` +`Params`  |
| FuncParam  |          para int `sym`           |
|  FuncCall  |      `Pushes`+call`FuncName`      |
|  FuncPush  |             push`sym`             |
|  FuncRet   |             ret `sym`             |
|  VarDecl   |       var int `sym` = `sym`       |
| ConstDecl  |     const int `sym1` = `sym2`     |
|    Jump    |          `goto` `label`           |
|    Cmp     | `cmp` `sym1` `sym2`+`res` `label` |
|   Printf   |  `printf` `str` |
|    Get     |  `scanf` `sym1` + `sym2` =`sym1`  |
| ArrayDecl  |   arr int `arrayname[sym][sym]`   |
| ArrayLoad  |     `arrayname[index]`=`sym`      |
| ArrayStore |     `sym`=`arrayname[index]`      |
| Label | `Label:` |

​		具体的实现可能和此处的设计稍微有一些出入，但不会特别大。sym考虑使用上一次的Symbol实现。中间代码对应的每一个类都存出了相应的信息，以便代码生成器读取使用。比如ArrayDecl就存储了该数组对应的VarSymbol（这其中包含了很多重要的信息，包括数组的维数、是否是全局数组、数组的初始值等等），Exp则存储了数组的操作数以及操作方法（可能有两个操作数，也可能有一个操作数）。

​		中间代码是链接递归下降程序和目标代码的桥梁，它在尽可能保存递归下降程序分析出的信息的同时，也需要贴近目标码的格式。这会有一定的难度，毕竟递归下降程序产生的是分析树，而中间代码是线性表示。为了实现这种转换，我们通常在语法分析树中添加语义动作来完成这一部分的翻译（当然，预计需要考虑的细节会非常多，语义动作可能很难做到提前设计完备和设计规范，应当尽快实现主要功能，然后逐步实现细节）。

​		结合上面为中间代码设计的类，我计划再次遍历语法树，并结合已经构建的符号表实现中间代码生成。

### 中间代码生成器

​		建立一个Generator类，用于描述一个生成器的对象，它可以调用符号表TableMaster，也可以调用语法树TreeHead。生成器通过递归下降地分析语法树的语法成分和操作符号表来实现中间代码生成的基本逻辑，即可以理解为在原有的语法树基础上插入新的**语义动作**来实现分析。

​		之前提到过，中间代码是一条沟通的桥梁，它必须兼顾语法树的树结构的特点和目标码线性排列的特点。这里分别举两个典型的例子：

- while块和break、continue语句。在生成针对break和continue的跳转语句时，我们需要考虑**程序到底处于哪一层**。由于在语法树中，符号表层次可以随着block层次一同移动，我们就可以沿着当前符号表向上查询最近的while块，这里利用了树结构的优势（在错误处理中也是这么做的）
- 表达式的生成。表达式在目标代码中是线性计算的，优先级就会是一个非常重要的考虑因素。不过文法已经帮我们解决好了这个问题，我们只需要在语法树中线性生成即可。

​		思考过这些细节，我们就可以为递归下降生成中间代码的程序编写语义动作了。一些函数可以维持简单的形态，只负责向下进入子函数（在作本部分时已经实现了部分架构）：

```java
    /* GenFuncDef函数只需要选择子程序进入即可 */
		public void GenFuncDef(Node node) {
        ArrayList<Node> children = node.getChildren();
        AddLabel(children.get(1).getContext(), false);
        FuncDecl funcDecl = AddFuncDef(children);
        for (Node item : children) {
            switch (item.getContext()) {
                case "<FuncFParams>":
                    funcDecl.getFuncParams().addAll(GenFuncFParams(item));
                    break;
                case "<Block>":
                    GenBlock(item);
                    break;
            }
        }
```

​		另一些函数则需要提取、生成语法树中的信息并且向上返回：

```java
    /* GenAddExp函数调用子程序进行计算，并返回一个表达式的结果 */
		public String GenAddExp(Node node) {
				......
        for (Node item : children) {
            if (item.getContext().equals("<MulExp>")) {
                symbols.add(GenMulExp(item));
            } else if (!item.getContext().equals("<AddExp>")) { /* 当前Node对应一个运算符 */
                symbols.add(item.getContext());
            }
        }
				......
        Merge(...);
      	......
        return ResultStack.pop();
    }
```

​		还有更复杂的函数。在子程序返回足够的信息后，他们会调用一系列的Add方法向一个存储中间代码的容器中加入中间代码的对象：

```java
    /* 加入中间代码的函数 */
		public VarDecl AddVarDecl(VarSymbol symbol, String name) {
        VarDecl varDecl = new VarDecl(symbol, name, symbol.isGlobal());
        iCodes.add(varDecl);
        return varDecl;
    }

    public ArrayDecl AddArrayDecl(VarSymbol symbol) {
        ArrayDecl arrayDecl = new ArrayDecl(symbol, IdentifyVarLevel(symbol), symbol.isGlobal());
        iCodes.add(arrayDecl);
        return arrayDecl;
    }
```

​		综上，编码的关键就变成了**如何在保证正确性的前提下，搜索并返回完全且关键的信息**。这里可以举一些例子：

- 数组声明时的维数。数组声明时的维数是可计算的，也必须在生成中间代码前计算出来（否则无法分配地址空间），这需要从ConstInitVal中获取信息。
- 表达式的左右操作数。这需要Exp系列的递归下降子函数来生成分析，通常应当是子函数得到计算结果，返回到父函数，父函数再利用这一结果计算返回。
- Printf语句。需要在这一子程序中翻译所需要打印的字符串以及占位符对应的信息，可能会出现复杂的表达式运算与函数的调用。
- 短路求值。这里主要和LAndExp、LOrExp有关，但由于and和or运算只出现在Cond中，并不需要我们生成其对应的运算，而是需要按照短路求值的逻辑分配标签。

​		除此之外，还有很多实现上的细节需要考虑，在设计时不可能一一列举。我将会在实现后提到一些比较关键的设计细节。

## 七、目标代码生成

​		目标代码生成是基于中间代码生成的，每个人的中间代码设计可能在细节上有差异，所以不能完全参考他人的目标代码生成方法。不过有一些宏观的设计是值得参考的。

### 规范MIPS代码种类

​		和生成中间代码一样，我们将目标代码封装成类，并重写其toString方法以提供灵活的目标代码生成接口。首先需要考虑将要选择哪些MIPS指令作为目标代码进行生成。

|     类     |                   目标MIPS码                   |      功能      |
| :--------: | :--------------------------------------------: | :------------: |
| Calculate  |       `op $r1 $r2` ` op $r1 $r2 val/$r3`       | 加减乘除模计算 |
|   Branch   |           `beq/bne $r1` ` $r2 label`           |    比较跳转    |
|   JumpTo   |             `j/jal label` `jr $ra`             |    直接跳转    |
|  Syscall   |            `li $v0 value` `syscall`            |    系统调用    |
| MipsLabel  |                  `labelname:`                  |      标签      |
|    Load    |         `lw/la $r1 offset($r2)/label`          |    访存指令    |
|   Store    |           `sw $r1 offset($r2)/label`           |    存储指令    |
|   MDUnit   |           `mthi/mfhi/mtlo/mflo $reg`           |   乘除寄存器   |
| StackInstr | `subi/addi $sp $sp offset` `sw/lw $reg 0($sp)` |   栈指针管理   |
|   Global   |       `name: .word` `name: .asciiz str`        |    全局变量    |
|   Space    |                    `.data`                     |      空间      |
|   Assign   |       `li $reg value` `move $reg1 $reg2`       |      赋值      |

​		在类的内部设置一些标识码和缺省值，以应对同一类下不同的MIPS代码生成要求。

### 全局量的声明与保存

​		首先处理全局量。根据MIPS使用规范，这些量应当存放在.data字段下，并且需要为其开辟空间。全局变量包括：

- 普通变量。由于之前已经用唯一标识将其标记，可以直接使用唯一标识为其创建标签并开辟空间。需要注意的是，全局变量未必具有初始值，或者初始值依赖于表达式计算，但是仍需要先开辟空间。
- 数组。全局数组也需要开辟空间，可以使用.space进行开辟。对于const数组，其初始值已知，在.data中逐一赋值即可；对于没有初始值的数组，可以默认填0。
- 字符串常量。这类全局量在本次编译作业中仅仅以要输出的字符串的形式出现，可以直接使用`<name>: .asciiz "<String>"`的方式进行全局声明
