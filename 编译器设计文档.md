# 编译器设计文档

## 一、参考编译器介绍

​		本人主要参考了课程组提供的PL0编译器和Pascal-S编译器，以及Rust编译器的部分设计思想。

## 二、 编译器总体设计

### 1.文件组织结构及类介绍

​		Java文件的组织结构能在一定程度上体现我在某一阶段的设计思想。

​		举出src文件下的文件树：

```shell
├── ClassFile
│   ├── ......
├── Tool
│   ├── ......
└── Compiler.java
```

​		ClassFile是用于存放枚举类和对象类的，枚举类都存放了可供全局访问的、易于理解的静态变量以及访问接口，对象类提供了存储单元。这以便于将繁琐而有需要长期访问的固定数据和主程序剖离，降低耦合度。例如，我用CategoryCode类存放了类别码，并提供了查询接口；用TokenType类划分了Token的类型，并提供了识别Token类型的接口；Token类为每一个语法分析单元提供了可实例化的对象，在提高信息存储能力的同时增加了代码的可扩展性。

​		Tool用于存放工具类，包括Lexer、Parser等，这部分是编译器的动态程序。

​		Compiler是编译器的入口程序，不用过多介绍。

### 2.

##   三、词法分析设计

### 编码前设计：

​		词法分析主要由Lexer来完成。在参考了其他编译器的设计以及阅读了实验手册后，我放弃了使用有限自动机设计词法分析器的方法，而采取了参考手册给出的**方案3**。词法分析是一个线性过程，而所给的Sysy文法也不是很复杂，方案三的**分类+扫描**的设计思维和我的设计思维较为吻合。尤其需要注意的是我们时刻需要维护一个当前扫描到的符号的指针，和一个当前符号所处行数的int类型变量，以便于我们对词法分析过程进行检查和为以后的设计预留接口。

​		此处，需要设计Token类来存放Token，存储Token的相关信息，以便于后面语法分析阶段构造语法树和生成代码时建立符号表（目前可以想到的需要存放的信息较少，以后会增加）；同时需要构造一个枚举类用于方便地查取类别码，配置访问接口（Pascal-S编译器用宏定义来解决这个问题，但面向对象给我们提供了代码可读性更高的解决方法）。

### 完成编码：

​		词法分析器Lexer的具体实现和设计时构想的思路基本一致，没有遇到特别大的困难，官方评测和辅助样例库也都是一次通过，显得相当顺利。下面介绍一些实现上的具体细节。

#### **读入**

​		一开始，我尚不是很了解Java的String类型存储的方法，以为换行符、空白符会影响到计数和判断（当然，我在学习C语言的时候就应该知道这是杞人忧天），所以想要实现一个边读入边分析（一次读入一行）的词法分析器。但是考虑到这样会导致功能的高耦合，很不利于Debug，于是我和师兄沟通交流，最后决定采取将所有文件读入为一个长串进行分析，在文件的换行处插入换行符。这虽然是一个很细小的细节，但你的词法分析方法可能长达几百行，如果在这个函数中糅合乱七八糟的功能，很可能会出现问题。

<img src="/Users/enqurance/Desktop/BUAA/大三上/编译/Complier/DocPics/Lexer1.png" alt="Lexer1" style="zoom: 25%;" />

#### Token的识别

​		具体到识别的阶段，Token的识别还可以细分为好几类。针对每一类制定具体的识别方案有助于我们验证自己识别方法的正确性并加快编码的速度、提高代码复用率。

- 读入一个字符即可识别Token类型。这其中包括+、-、*、（等简单符号。这类符号很好识别，只要读入就可以认为获得了一个Token
- 前缀同型类。这类Token的前面几个字符可能相同，如==、>=、//、等，需要在读入的时候顺便看一眼下一个字符，以正确判断到底遇到了何种Token
- 循环终止类。这类Token需要我们使用while循环不断向前看字符，直至到达该类字符的终止条件，包括/**/、空白字符等。与此同时，要注意遇到这些字符的时候很大概率会遇到换行，需要维护行数计数器

​		第一类Token的识别很简单，几乎不用考虑什么；第二三类Token的识别需要有一些技巧，并且要防止越界情况的发生。

#### 枚举类

​		CategoryCode是我建立的一个枚举类，这个类用于存放和查询Token的类别码，这个主意也是和别人讨论想出来的，其目的也是为了降低代码耦合度。除了使用public static修饰的String来提供外部访问功能外，还建立了一个HashMap用于映射具体字符到类别码的HashMap。这一部分的代码是手敲的，没有什么难度，只要不打错字即可。

### 词法分析总结：

​		总的来讲，词法分析器设计起来没有什么难度，麻烦的只是一直在做一些重复的工作、关注一些琐碎的细节。当然，逐步提高难度令同学们逐渐适应增量开发的过程，我想这是课程组精心考虑过的。

## 四、语法分析设计

​		由于在大二下学期参加过OO课程，我对递归下降的分析过程有了初步的感知。但在参加理论课程后才发现，相比我当时自己写的"递归下降"，真正的递归下降是很规范化的（怪不得我当时写了这么多Bug）。在本阶段，我也打算采取递归下降的分析方法实现语法分析设计。很显然，在我的设计中语法分析器Parser是独立于词法器的；而有的同学可能将这两个过程设计在一起。