CONSTTK const
INTTK int
IDENFR ConstA
ASSIGN =
INTCON 1
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<ConstExp>
<ConstInitVal>
<ConstDef>
COMMA ,
IDENFR tmpConst
LBRACK [
INTCON 2
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<ConstExp>
RBRACK ]
ASSIGN =
LBRACE {
INTCON 1
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<ConstExp>
<ConstInitVal>
COMMA ,
INTCON 3
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<ConstExp>
<ConstInitVal>
RBRACE }
<ConstInitVal>
<ConstDef>
SEMICN ;
<ConstDecl>
CONSTTK const
INTTK int
IDENFR S
LBRACK [
INTCON 6
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<ConstExp>
RBRACK ]
ASSIGN =
LBRACE {
INTCON 1
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<ConstExp>
<ConstInitVal>
COMMA ,
INTCON 3
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<ConstExp>
<ConstInitVal>
COMMA ,
INTCON 7
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<ConstExp>
<ConstInitVal>
COMMA ,
INTCON 6
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<ConstExp>
<ConstInitVal>
COMMA ,
INTCON 5
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<ConstExp>
<ConstInitVal>
COMMA ,
INTCON 5
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<ConstExp>
<ConstInitVal>
RBRACE }
<ConstInitVal>
<ConstDef>
SEMICN ;
<ConstDecl>
CONSTTK const
INTTK int
IDENFR cccA
ASSIGN =
INTCON 1
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<ConstExp>
<ConstInitVal>
<ConstDef>
COMMA ,
IDENFR cccB
ASSIGN =
INTCON 2
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<ConstExp>
<ConstInitVal>
<ConstDef>
COMMA ,
IDENFR cccC
ASSIGN =
INTCON 4
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<ConstExp>
<ConstInitVal>
<ConstDef>
SEMICN ;
<ConstDecl>
CONSTTK const
INTTK int
IDENFR Vect2
LBRACK [
INTCON 2
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<ConstExp>
RBRACK ]
LBRACK [
INTCON 3
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<ConstExp>
RBRACK ]
ASSIGN =
LBRACE {
LBRACE {
INTCON 1
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<ConstExp>
<ConstInitVal>
COMMA ,
INTCON 2
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<ConstExp>
<ConstInitVal>
COMMA ,
INTCON 4
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<ConstExp>
<ConstInitVal>
RBRACE }
<ConstInitVal>
COMMA ,
LBRACE {
INTCON 8
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<ConstExp>
<ConstInitVal>
COMMA ,
INTCON 16
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<ConstExp>
<ConstInitVal>
COMMA ,
INTCON 32
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<ConstExp>
<ConstInitVal>
RBRACE }
<ConstInitVal>
RBRACE }
<ConstInitVal>
<ConstDef>
SEMICN ;
<ConstDecl>
INTTK int
IDENFR A
ASSIGN =
IDENFR ConstA
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
MULT *
INTCON 2
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
PLUS +
INTCON 1
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
<InitVal>
<VarDef>
SEMICN ;
<VarDecl>
INTTK int
IDENFR D
LBRACK [
INTCON 3
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<ConstExp>
RBRACK ]
ASSIGN =
LBRACE {
IDENFR S
LBRACK [
INTCON 1
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
<InitVal>
COMMA ,
IDENFR S
LBRACK [
INTCON 3
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
<InitVal>
COMMA ,
IDENFR S
LBRACK [
INTCON 5
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
<InitVal>
RBRACE }
<InitVal>
<VarDef>
SEMICN ;
<VarDecl>
INTTK int
IDENFR c
LBRACK [
INTCON 3
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<ConstExp>
RBRACK ]
LBRACK [
INTCON 4
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<ConstExp>
RBRACK ]
<VarDef>
SEMICN ;
<VarDecl>
INTTK int
IDENFR globalVal
ASSIGN =
INTCON 0
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
<InitVal>
<VarDef>
SEMICN ;
<VarDecl>
VOIDTK void
<FuncType>
IDENFR noReturn
LPARENT (
RPARENT )
LBRACE {
PRINTFTK printf
LPARENT (
STRCON "This Function has no return!\n"
RPARENT )
SEMICN ;
<Stmt>
RBRACE }
<Block>
<FuncDef>
INTTK int
<FuncType>
IDENFR intReturn
LPARENT (
RPARENT )
LBRACE {
PRINTFTK printf
LPARENT (
STRCON "This Function has int return!\n"
RPARENT )
SEMICN ;
<Stmt>
RETURNTK return
INTCON 0
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
SEMICN ;
<Stmt>
RBRACE }
<Block>
<FuncDef>
INTTK int
<FuncType>
IDENFR multiply_and_add
LPARENT (
INTTK int
IDENFR a
<FuncFParam>
COMMA ,
INTTK int
IDENFR b
<FuncFParam>
COMMA ,
INTTK int
IDENFR c
<FuncFParam>
<FuncFParams>
RPARENT )
LBRACE {
PRINTFTK printf
LPARENT (
STRCON "multiply_and_add: a=%d b=%d c=%d\n"
COMMA ,
IDENFR a
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
COMMA ,
IDENFR b
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
COMMA ,
IDENFR c
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RPARENT )
SEMICN ;
<Stmt>
RETURNTK return
IDENFR a
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
MULT *
IDENFR b
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
PLUS +
IDENFR c
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
SEMICN ;
<Stmt>
RBRACE }
<Block>
<FuncDef>
INTTK int
<FuncType>
IDENFR condReturn
LPARENT (
INTTK int
IDENFR val
<FuncFParam>
<FuncFParams>
RPARENT )
LBRACE {
IFTK if
LPARENT (
IDENFR val
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
EQL ==
INTCON 1
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
<LAndExp>
<LOrExp>
<Cond>
RPARENT )
LBRACE {
RETURNTK return
INTCON 3
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
SEMICN ;
<Stmt>
RBRACE }
<Block>
<Stmt>
ELSETK else
IFTK if
LPARENT (
IDENFR val
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
EQL ==
INTCON 2
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
<LAndExp>
<LOrExp>
<Cond>
RPARENT )
LBRACE {
RETURNTK return
INTCON 4
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
SEMICN ;
<Stmt>
RBRACE }
<Block>
<Stmt>
ELSETK else
IFTK if
LPARENT (
IDENFR val
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
EQL ==
INTCON 3
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
<LAndExp>
<LOrExp>
<Cond>
RPARENT )
LBRACE {
RETURNTK return
INTCON 8
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
SEMICN ;
<Stmt>
RBRACE }
<Block>
<Stmt>
ELSETK else
LBRACE {
RETURNTK return
INTCON 10
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
SEMICN ;
<Stmt>
RBRACE }
<Block>
<Stmt>
<Stmt>
<Stmt>
<Stmt>
RETURNTK return
INTCON 0
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
SEMICN ;
<Stmt>
RBRACE }
<Block>
<FuncDef>
INTTK int
<FuncType>
IDENFR add
LPARENT (
INTTK int
IDENFR a
<FuncFParam>
COMMA ,
INTTK int
IDENFR b
<FuncFParam>
<FuncFParams>
RPARENT )
LBRACE {
IDENFR globalVal
<LVal>
ASSIGN =
IDENFR globalVal
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
PLUS +
INTCON 1
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
SEMICN ;
<Stmt>
RETURNTK return
IDENFR a
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
PLUS +
IDENFR b
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
SEMICN ;
<Stmt>
RBRACE }
<Block>
<FuncDef>
INTTK int
MAINTK main
LPARENT (
RPARENT )
LBRACE {
PRINTFTK printf
LPARENT (
STRCON "20373649\n"
RPARENT )
SEMICN ;
<Stmt>
IDENFR noReturn
LPARENT (
RPARENT )
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
SEMICN ;
<Stmt>
INTTK int
IDENFR ans
ASSIGN =
IDENFR multiply_and_add
LPARENT (
IDENFR S
LBRACK [
INTCON 0
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
COMMA ,
INTCON 3
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
COMMA ,
INTCON 9
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
<FuncRParams>
RPARENT )
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
<InitVal>
<VarDef>
SEMICN ;
<VarDecl>
LBRACE {
RBRACE }
<Block>
<Stmt>
LBRACE {
RBRACE }
<Block>
<Stmt>
INTTK int
IDENFR WeekDay
ASSIGN =
INTCON 2
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
<InitVal>
<VarDef>
SEMICN ;
<VarDecl>
IFTK if
LPARENT (
IDENFR WeekDay
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
NEQ !=
INTCON 1
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
<LAndExp>
<LOrExp>
<Cond>
RPARENT )
LBRACE {
IFTK if
LPARENT (
IDENFR WeekDay
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
NEQ !=
INTCON 2
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
<LAndExp>
<LOrExp>
<Cond>
RPARENT )
LBRACE {
PRINTFTK printf
LPARENT (
STRCON "Weekday != 2\n"
RPARENT )
SEMICN ;
<Stmt>
RBRACE }
<Block>
<Stmt>
ELSETK else
LBRACE {
PRINTFTK printf
LPARENT (
STRCON "Weekday == 2\n"
RPARENT )
SEMICN ;
<Stmt>
RBRACE }
<Block>
<Stmt>
<Stmt>
RBRACE }
<Block>
<Stmt>
ELSETK else
LBRACE {
PRINTFTK printf
LPARENT (
STRCON "Weekday == 1\n"
RPARENT )
SEMICN ;
<Stmt>
RBRACE }
<Block>
<Stmt>
<Stmt>
CONSTTK const
INTTK int
IDENFR ConstA
ASSIGN =
INTCON 2
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<ConstExp>
<ConstInitVal>
<ConstDef>
SEMICN ;
<ConstDecl>
LBRACE {
PRINTFTK printf
LPARENT (
STRCON "redefined ConstA = %d\n"
COMMA ,
IDENFR ConstA
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RPARENT )
SEMICN ;
<Stmt>
RBRACE }
<Block>
<Stmt>
LBRACE {
LBRACE {
LBRACE {
RBRACE }
<Block>
<Stmt>
RBRACE }
<Block>
<Stmt>
RBRACE }
<Block>
<Stmt>
IDENFR multiply_and_add
LPARENT (
IDENFR condReturn
LPARENT (
INTCON 1
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
<FuncRParams>
RPARENT )
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
COMMA ,
IDENFR condReturn
LPARENT (
INTCON 2
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
<FuncRParams>
RPARENT )
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
COMMA ,
IDENFR condReturn
LPARENT (
INTCON 3
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
<FuncRParams>
RPARENT )
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
<FuncRParams>
RPARENT )
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
SEMICN ;
<Stmt>
INTTK int
IDENFR bin
ASSIGN =
INTCON 0
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
<InitVal>
<VarDef>
SEMICN ;
<VarDecl>
INTTK int
IDENFR decimal
ASSIGN =
INTCON 23
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
<InitVal>
<VarDef>
SEMICN ;
<VarDecl>
INTTK int
IDENFR origin_dec
ASSIGN =
IDENFR decimal
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
<InitVal>
<VarDef>
SEMICN ;
<VarDecl>
INTTK int
IDENFR ten
ASSIGN =
INTCON 1
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
<InitVal>
<VarDef>
SEMICN ;
<VarDecl>
WHILETK while
LPARENT (
IDENFR decimal
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
NEQ !=
INTCON 0
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
<LAndExp>
<LOrExp>
<Cond>
RPARENT )
LBRACE {
IDENFR bin
<LVal>
ASSIGN =
IDENFR bin
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
PLUS +
IDENFR ten
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
MULT *
LPARENT (
IDENFR decimal
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
MOD %
PLUS +
<UnaryOp>
MINU -
<UnaryOp>
PLUS +
<UnaryOp>
MINU -
<UnaryOp>
INTCON 2
<Number>
<PrimaryExp>
<UnaryExp>
<UnaryExp>
<UnaryExp>
<UnaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RPARENT )
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
SEMICN ;
<Stmt>
INTTK int
IDENFR tmp
ASSIGN =
IDENFR decimal
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
DIV /
PLUS +
<UnaryOp>
INTCON 2
<Number>
<PrimaryExp>
<UnaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
<InitVal>
<VarDef>
SEMICN ;
<VarDecl>
IDENFR decimal
<LVal>
ASSIGN =
IDENFR tmp
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
SEMICN ;
<Stmt>
IDENFR ten
<LVal>
ASSIGN =
IDENFR ten
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
MULT *
INTCON 10
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
SEMICN ;
<Stmt>
RBRACE }
<Block>
<Stmt>
<Stmt>
PRINTFTK printf
LPARENT (
STRCON "The binary of decimal %d is %d.\n"
COMMA ,
IDENFR origin_dec
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
COMMA ,
IDENFR bin
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RPARENT )
SEMICN ;
<Stmt>
IFTK if
LPARENT (
IDENFR bin
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
NEQ !=
INTCON 0
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
<LAndExp>
<LOrExp>
<Cond>
RPARENT )
PRINTFTK printf
LPARENT (
STRCON "binary != 0\n"
RPARENT )
SEMICN ;
<Stmt>
<Stmt>
INTTK int
IDENFR i
ASSIGN =
INTCON 3
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
<InitVal>
<VarDef>
COMMA ,
IDENFR t
ASSIGN =
INTCON 0
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
<InitVal>
<VarDef>
SEMICN ;
<VarDecl>
INTTK int
IDENFR num
LBRACK [
INTCON 4
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
MINU -
INTCON 1
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<ConstExp>
RBRACK ]
<VarDef>
SEMICN ;
<VarDecl>
WHILETK while
LPARENT (
IDENFR i
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
NEQ !=
INTCON 0
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
<LAndExp>
<LOrExp>
<Cond>
RPARENT )
LBRACE {
IDENFR num
LBRACK [
IDENFR t
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
ASSIGN =
GETINTTK getint
LPARENT (
RPARENT )
SEMICN ;
<Stmt>
IDENFR t
<LVal>
ASSIGN =
IDENFR t
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
PLUS +
INTCON 1
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
SEMICN ;
<Stmt>
IDENFR i
<LVal>
ASSIGN =
IDENFR i
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
MINU -
INTCON 1
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
SEMICN ;
<Stmt>
RBRACE }
<Block>
<Stmt>
<Stmt>
IDENFR D
LBRACK [
INTCON 0
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
ASSIGN =
IDENFR num
LBRACK [
INTCON 0
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
SEMICN ;
<Stmt>
IDENFR D
LBRACK [
INTCON 1
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
ASSIGN =
IDENFR num
LBRACK [
INTCON 1
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
SEMICN ;
<Stmt>
IDENFR D
LBRACK [
INTCON 2
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
ASSIGN =
IDENFR num
LBRACK [
INTCON 2
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
SEMICN ;
<Stmt>
IFTK if
LPARENT (
IDENFR num
LBRACK [
INTCON 0
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
GEQ >=
IDENFR num
LBRACK [
INTCON 1
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
<LAndExp>
AND &&
IDENFR num
LBRACK [
INTCON 1
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
GEQ >=
IDENFR num
LBRACK [
INTCON 2
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
<LAndExp>
<LOrExp>
<Cond>
RPARENT )
LBRACE {
IDENFR num
LBRACK [
INTCON 0
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
ASSIGN =
IDENFR D
LBRACK [
INTCON 2
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
SEMICN ;
<Stmt>
IDENFR num
LBRACK [
INTCON 1
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
ASSIGN =
IDENFR D
LBRACK [
INTCON 1
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
SEMICN ;
<Stmt>
IDENFR num
LBRACK [
INTCON 2
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
ASSIGN =
IDENFR D
LBRACK [
INTCON 0
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
SEMICN ;
<Stmt>
RBRACE }
<Block>
<Stmt>
ELSETK else
IFTK if
LPARENT (
IDENFR num
LBRACK [
INTCON 0
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
GEQ >=
IDENFR num
LBRACK [
INTCON 2
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
<LAndExp>
AND &&
IDENFR num
LBRACK [
INTCON 2
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
GEQ >=
IDENFR num
LBRACK [
INTCON 1
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
<LAndExp>
<LOrExp>
<Cond>
RPARENT )
LBRACE {
IDENFR num
LBRACK [
INTCON 0
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
ASSIGN =
IDENFR D
LBRACK [
INTCON 1
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
SEMICN ;
<Stmt>
IDENFR num
LBRACK [
INTCON 1
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
ASSIGN =
IDENFR D
LBRACK [
INTCON 2
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
SEMICN ;
<Stmt>
IDENFR num
LBRACK [
INTCON 2
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
ASSIGN =
IDENFR D
LBRACK [
INTCON 0
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
SEMICN ;
<Stmt>
RBRACE }
<Block>
<Stmt>
ELSETK else
IFTK if
LPARENT (
IDENFR num
LBRACK [
INTCON 1
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
GEQ >=
IDENFR num
LBRACK [
INTCON 0
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
<LAndExp>
AND &&
IDENFR num
LBRACK [
INTCON 0
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
GEQ >=
IDENFR num
LBRACK [
INTCON 2
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
<LAndExp>
<LOrExp>
<Cond>
RPARENT )
LBRACE {
IDENFR num
LBRACK [
INTCON 0
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
ASSIGN =
IDENFR D
LBRACK [
INTCON 2
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
SEMICN ;
<Stmt>
IDENFR num
LBRACK [
INTCON 1
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
ASSIGN =
IDENFR D
LBRACK [
INTCON 0
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
SEMICN ;
<Stmt>
IDENFR num
LBRACK [
INTCON 2
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
ASSIGN =
IDENFR D
LBRACK [
INTCON 1
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
SEMICN ;
<Stmt>
RBRACE }
<Block>
<Stmt>
ELSETK else
IFTK if
LPARENT (
IDENFR num
LBRACK [
INTCON 1
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
GEQ >=
IDENFR num
LBRACK [
INTCON 2
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
<LAndExp>
AND &&
IDENFR num
LBRACK [
INTCON 2
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
GEQ >=
IDENFR num
LBRACK [
INTCON 0
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
<LAndExp>
<LOrExp>
<Cond>
RPARENT )
LBRACE {
IDENFR num
LBRACK [
INTCON 0
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
ASSIGN =
IDENFR D
LBRACK [
INTCON 0
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
SEMICN ;
<Stmt>
IDENFR num
LBRACK [
INTCON 1
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
ASSIGN =
IDENFR D
LBRACK [
INTCON 2
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
SEMICN ;
<Stmt>
IDENFR num
LBRACK [
INTCON 2
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
ASSIGN =
IDENFR D
LBRACK [
INTCON 1
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
SEMICN ;
<Stmt>
RBRACE }
<Block>
<Stmt>
ELSETK else
IFTK if
LPARENT (
IDENFR num
LBRACK [
INTCON 2
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
GEQ >=
IDENFR num
LBRACK [
INTCON 0
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
<LAndExp>
AND &&
IDENFR num
LBRACK [
INTCON 0
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
GEQ >=
IDENFR num
LBRACK [
INTCON 1
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
<LAndExp>
<LOrExp>
<Cond>
RPARENT )
LBRACE {
IDENFR num
LBRACK [
INTCON 0
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
ASSIGN =
IDENFR D
LBRACK [
INTCON 1
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
SEMICN ;
<Stmt>
IDENFR num
LBRACK [
INTCON 1
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
ASSIGN =
IDENFR D
LBRACK [
INTCON 0
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
SEMICN ;
<Stmt>
IDENFR num
LBRACK [
INTCON 2
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
ASSIGN =
IDENFR D
LBRACK [
INTCON 2
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
SEMICN ;
<Stmt>
RBRACE }
<Block>
<Stmt>
ELSETK else
IFTK if
LPARENT (
IDENFR num
LBRACK [
INTCON 2
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
GEQ >=
IDENFR num
LBRACK [
INTCON 1
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
<LAndExp>
AND &&
IDENFR num
LBRACK [
INTCON 0
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
LEQ <=
IDENFR num
LBRACK [
INTCON 1
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
<LAndExp>
<LOrExp>
<Cond>
RPARENT )
LBRACE {
IDENFR num
LBRACK [
INTCON 0
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
ASSIGN =
IDENFR D
LBRACK [
INTCON 0
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
SEMICN ;
<Stmt>
IDENFR num
LBRACK [
INTCON 1
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
ASSIGN =
IDENFR D
LBRACK [
INTCON 1
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
SEMICN ;
<Stmt>
IDENFR num
LBRACK [
INTCON 2
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
ASSIGN =
IDENFR D
LBRACK [
INTCON 2
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
SEMICN ;
<Stmt>
RBRACE }
<Block>
<Stmt>
ELSETK else
LBRACE {
PRINTFTK printf
LPARENT (
STRCON "This situation should never happen!\n"
RPARENT )
SEMICN ;
<Stmt>
RBRACE }
<Block>
<Stmt>
<Stmt>
<Stmt>
<Stmt>
<Stmt>
<Stmt>
<Stmt>
PRINTFTK printf
LPARENT (
STRCON "The correct sort of the input array is: %d %d %d.\n"
COMMA ,
IDENFR num
LBRACK [
INTCON 0
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
COMMA ,
IDENFR num
LBRACK [
INTCON 1
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
COMMA ,
IDENFR num
LBRACK [
INTCON 2
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RBRACK ]
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RPARENT )
SEMICN ;
<Stmt>
IFTK if
LPARENT (
INTCON 0
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
EQL ==
INTCON 2
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
<LAndExp>
<LOrExp>
OR ||
INTCON 3
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
EQL ==
INTCON 5
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
<LAndExp>
<LOrExp>
OR ||
INTCON 2
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
EQL ==
INTCON 2
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
<LAndExp>
<LOrExp>
OR ||
LPARENT (
INTCON 3
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
PLUS +
INTCON 1
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RPARENT )
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
EQL ==
INTCON 6
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
<LAndExp>
<LOrExp>
OR ||
IDENFR intReturn
LPARENT (
RPARENT )
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
EQL ==
INTCON 0
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
<LAndExp>
<LOrExp>
<Cond>
RPARENT )
LBRACE {
PRINTFTK printf
LPARENT (
STRCON "short circuit evaluation: Or\n"
RPARENT )
SEMICN ;
<Stmt>
RBRACE }
<Block>
<Stmt>
<Stmt>
IFTK if
LPARENT (
INTCON 3
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
GRE >
INTCON 2
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
<LAndExp>
AND &&
NOT !
<UnaryOp>
INTCON 0
<Number>
<PrimaryExp>
<UnaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
<LAndExp>
AND &&
IDENFR add
LPARENT (
INTCON 1
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
COMMA ,
INTCON 2
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
<FuncRParams>
RPARENT )
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
EQL ==
INTCON 4
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
<LAndExp>
AND &&
IDENFR add
LPARENT (
INTCON 1
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
COMMA ,
INTCON 4
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
<FuncRParams>
RPARENT )
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
EQL ==
INTCON 5
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
<LAndExp>
<LOrExp>
<Cond>
RPARENT )
LBRACE {
PRINTFTK printf
LPARENT (
STRCON "Never happen!\n"
RPARENT )
SEMICN ;
<Stmt>
RBRACE }
<Block>
<Stmt>
<Stmt>
IFTK if
LPARENT (
IDENFR globalVal
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
EQL ==
INTCON 1
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<RelExp>
<EqExp>
<LAndExp>
<LOrExp>
<Cond>
RPARENT )
LBRACE {
PRINTFTK printf
LPARENT (
STRCON "globalVal: %d. short circuit evaluation:And\n"
COMMA ,
IDENFR globalVal
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RPARENT )
SEMICN ;
<Stmt>
RBRACE }
<Block>
<Stmt>
ELSETK else
LBRACE {
PRINTFTK printf
LPARENT (
STRCON "globalVal: %d. short circuit evaluation:And Failed\n"
COMMA ,
IDENFR globalVal
<LVal>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
RPARENT )
SEMICN ;
<Stmt>
RBRACE }
<Block>
<Stmt>
<Stmt>
RETURNTK return
INTCON 0
<Number>
<PrimaryExp>
<UnaryExp>
<MulExp>
<AddExp>
<Exp>
SEMICN ;
<Stmt>
RBRACE }
<Block>
<MainFuncDef>
<CompUnit>
