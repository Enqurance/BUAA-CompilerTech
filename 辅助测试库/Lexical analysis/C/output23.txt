CONSTTK const
INTTK int
IDENFR Mod
ASSIGN =
INTCON 389
COMMA ,
IDENFR N
ASSIGN =
INTCON 100005
SEMICN ;
INTTK int
IDENFR a_to_the_a
COMMA ,
IDENFR cnt
ASSIGN =
INTCON 0
SEMICN ;
INTTK int
IDENFR n
SEMICN ;
VOIDTK void
IDENFR move
LPARENT (
INTTK int
IDENFR a
COMMA ,
INTTK int
IDENFR b
RPARENT )
LBRACE {
IDENFR cnt
ASSIGN =
IDENFR cnt
PLUS +
INTCON 1
SEMICN ;
IFTK if
LPARENT (
IDENFR cnt
MOD %
IDENFR Mod
EQL ==
INTCON 0
RPARENT )
LBRACE {
PRINTFTK printf
LPARENT (
STRCON "funcTest: move disk from %d to %d\n"
COMMA ,
IDENFR a
COMMA ,
IDENFR b
RPARENT )
SEMICN ;
RBRACE }
RBRACE }
VOIDTK void
IDENFR hanoi
LPARENT (
INTTK int
IDENFR n
COMMA ,
INTTK int
IDENFR a
COMMA ,
INTTK int
IDENFR b
COMMA ,
INTTK int
IDENFR c
RPARENT )
LBRACE {
IFTK if
LPARENT (
IDENFR n
EQL ==
INTCON 1
RPARENT )
LBRACE {
IDENFR move
LPARENT (
IDENFR a
COMMA ,
IDENFR c
RPARENT )
SEMICN ;
RETURNTK return
SEMICN ;
RBRACE }
IDENFR hanoi
LPARENT (
IDENFR n
MINU -
INTCON 1
COMMA ,
IDENFR a
COMMA ,
IDENFR c
COMMA ,
IDENFR b
RPARENT )
SEMICN ;
IDENFR move
LPARENT (
IDENFR a
COMMA ,
IDENFR c
RPARENT )
SEMICN ;
IDENFR hanoi
LPARENT (
IDENFR n
MINU -
INTCON 1
COMMA ,
IDENFR b
COMMA ,
IDENFR a
COMMA ,
IDENFR c
RPARENT )
SEMICN ;
RBRACE }
INTTK int
IDENFR qpow
LPARENT (
INTTK int
IDENFR a
COMMA ,
INTTK int
IDENFR b
RPARENT )
LBRACE {
INTTK int
IDENFR ans
ASSIGN =
INTCON 1
SEMICN ;
WHILETK while
LPARENT (
IDENFR b
RPARENT )
LBRACE {
IDENFR b
ASSIGN =
IDENFR b
DIV /
INTCON 2
SEMICN ;
IDENFR a
ASSIGN =
LPARENT (
IDENFR a
MULT *
IDENFR a
RPARENT )
MOD %
IDENFR Mod
SEMICN ;
IFTK if
LPARENT (
IDENFR b
MOD %
INTCON 2
RPARENT )
LBRACE {
IDENFR ans
ASSIGN =
LPARENT (
IDENFR ans
MULT *
IDENFR a
RPARENT )
MOD %
IDENFR Mod
SEMICN ;
RBRACE }
RBRACE }
RETURNTK return
IDENFR ans
SEMICN ;
RBRACE }
INTTK int
IDENFR gcd
LPARENT (
INTTK int
IDENFR a
COMMA ,
INTTK int
IDENFR b
RPARENT )
LBRACE {
IFTK if
LPARENT (
NOT !
IDENFR b
RPARENT )
LBRACE {
RETURNTK return
IDENFR a
SEMICN ;
RBRACE }
RETURNTK return
IDENFR gcd
LPARENT (
IDENFR b
COMMA ,
IDENFR a
MOD %
IDENFR b
RPARENT )
SEMICN ;
RBRACE }
INTTK int
IDENFR testExp
LPARENT (
RPARENT )
LBRACE {
IDENFR a_to_the_a
ASSIGN =
IDENFR n
MULT *
IDENFR n
SEMICN ;
INTTK int
IDENFR k
ASSIGN =
IDENFR N
DIV /
IDENFR n
SEMICN ;
IDENFR n
MULT *
IDENFR n
DIV /
IDENFR n
PLUS +
IDENFR n
MINU -
IDENFR n
SEMICN ;
INTTK int
IDENFR b
ASSIGN =
IDENFR a_to_the_a
PLUS +
INTCON 1
SEMICN ;
INTTK int
IDENFR c
ASSIGN =
MINU -
PLUS +
MINU -
PLUS +
INTCON 2147483647
COMMA ,
IDENFR d
ASSIGN =
MINU -
INTCON 1
MINU -
IDENFR c
SEMICN ;
INTTK int
IDENFR t
ASSIGN =
LPARENT (
LPARENT (
LPARENT (
INTCON 1
MINU -
PLUS +
MINU -
IDENFR a_to_the_a
RPARENT )
MULT *
IDENFR b
DIV /
INTCON 3
MINU -
INTCON 2
PLUS +
IDENFR N
RPARENT )
MOD %
IDENFR Mod
RPARENT )
SEMICN ;
INTTK int
IDENFR e
ASSIGN =
IDENFR qpow
LPARENT (
IDENFR a_to_the_a
COMMA ,
IDENFR b
RPARENT )
SEMICN ;
LBRACE {
IDENFR b
ASSIGN =
INTCON 10
SEMICN ;
IDENFR c
ASSIGN =
INTCON 0
SEMICN ;
LBRACE {
IDENFR b
ASSIGN =
INTCON 7
SEMICN ;
IDENFR c
ASSIGN =
INTCON 8
SEMICN ;
PRINTFTK printf
LPARENT (
STRCON "blockTest: 7 == %d, 8 == %d\n"
COMMA ,
IDENFR b
COMMA ,
IDENFR c
RPARENT )
SEMICN ;
RBRACE }
INTTK int
IDENFR i
ASSIGN =
INTCON 0
SEMICN ;
WHILETK while
LPARENT (
INTCON 1
RPARENT )
LBRACE {
IDENFR i
ASSIGN =
IDENFR i
PLUS +
INTCON 1
SEMICN ;
IFTK if
LPARENT (
IDENFR i
MOD %
INTCON 2
NEQ !=
INTCON 0
RPARENT )
LBRACE {
CONTINUETK continue
SEMICN ;
RBRACE }
IFTK if
LPARENT (
IDENFR i
GEQ >=
IDENFR b
RPARENT )
LBRACE {
BREAKTK break
SEMICN ;
RBRACE }
ELSETK else
LBRACE {
IFTK if
LPARENT (
IDENFR c
LSS <
INTCON 10
RPARENT )
LBRACE {
IDENFR c
ASSIGN =
IDENFR c
PLUS +
IDENFR i
SEMICN ;
RBRACE }
ELSETK else
LBRACE {
IDENFR c
ASSIGN =
IDENFR c
MINU -
IDENFR i
SEMICN ;
RBRACE }
RBRACE }
RBRACE }
PRINTFTK printf
LPARENT (
STRCON "blockTest: 5 == %d, 12 == %d\n"
COMMA ,
IDENFR b
COMMA ,
IDENFR c
RPARENT )
SEMICN ;
RBRACE }
INTTK int
IDENFR f
ASSIGN =
IDENFR n
COMMA ,
IDENFR g
ASSIGN =
INTCON 0
SEMICN ;
IFTK if
LPARENT (
IDENFR f
LSS <
INTCON 0
RPARENT )
LBRACE {
IDENFR g
ASSIGN =
INTCON 10
SEMICN ;
RBRACE }
ELSETK else
LBRACE {
IFTK if
LPARENT (
IDENFR f
GRE >
INTCON 10
RPARENT )
LBRACE {
IDENFR g
ASSIGN =
INTCON 20
SEMICN ;
RBRACE }
ELSETK else
LBRACE {
IFTK if
LPARENT (
IDENFR f
EQL ==
IDENFR n
RPARENT )
LBRACE {
IDENFR g
ASSIGN =
INTCON 30
SEMICN ;
RBRACE }
RBRACE }
RBRACE }
IFTK if
LPARENT (
IDENFR f
LEQ <=
INTCON 10
RPARENT )
LBRACE {
IDENFR g
ASSIGN =
IDENFR g
PLUS +
IDENFR f
SEMICN ;
RBRACE }
PRINTFTK printf
LPARENT (
STRCON "Exptest: %d %d %d %d %d"
COMMA ,
IDENFR a_to_the_a
COMMA ,
IDENFR b
COMMA ,
IDENFR c
COMMA ,
IDENFR d
COMMA ,
IDENFR e
RPARENT )
SEMICN ;
PRINTFTK printf
LPARENT (
STRCON " %d %d %d\n"
COMMA ,
IDENFR f
COMMA ,
IDENFR g
COMMA ,
IDENFR t
RPARENT )
SEMICN ;
RETURNTK return
IDENFR gcd
LPARENT (
IDENFR f
COMMA ,
IDENFR g
RPARENT )
SEMICN ;
RBRACE }
INTTK int
MAINTK main
LPARENT (
RPARENT )
LBRACE {
PRINTFTK printf
LPARENT (
STRCON "20373569 the mafia~\n"
RPARENT )
SEMICN ;
IDENFR n
ASSIGN =
GETINTTK getint
LPARENT (
RPARENT )
SEMICN ;
IDENFR hanoi
LPARENT (
IDENFR n
COMMA ,
INTCON 1
COMMA ,
INTCON 2
COMMA ,
INTCON 3
RPARENT )
SEMICN ;
PRINTFTK printf
LPARENT (
STRCON "Exptest: %d\n"
COMMA ,
IDENFR testExp
LPARENT (
RPARENT )
RPARENT )
SEMICN ;
RETURNTK return
INTCON 0
SEMICN ;
RBRACE }
