INTTK int
IDENFR conflictMap
LBRACK [
INTCON 20
RBRACK ]
LBRACK [
INTCON 20
RBRACK ]
COMMA ,
IDENFR record
LBRACK [
INTCON 20
RBRACK ]
COMMA ,
IDENFR result
LBRACK [
INTCON 20
RBRACK ]
SEMICN ;
INTTK int
IDENFR minGroup
ASSIGN =
INTCON 30
COMMA ,
IDENFR m
ASSIGN =
INTCON 0
SEMICN ;
INTTK int
IDENFR global_var
ASSIGN =
INTCON 0
SEMICN ;
INTTK int
IDENFR func
LPARENT (
RPARENT )
LBRACE {
IDENFR global_var
ASSIGN =
IDENFR global_var
PLUS +
INTCON 1
SEMICN ;
RETURNTK return
INTCON 1
SEMICN ;
RBRACE }
VOIDTK void
IDENFR init
LPARENT (
RPARENT )
LBRACE {
INTTK int
IDENFR i
ASSIGN =
INTCON 0
SEMICN ;
WHILETK while
LPARENT (
IDENFR i
LSS <
INTCON 20
RPARENT )
LBRACE {
IDENFR record
LBRACK [
IDENFR i
RBRACK ]
ASSIGN =
INTCON 0
SEMICN ;
IDENFR result
LBRACK [
IDENFR i
RBRACK ]
ASSIGN =
INTCON 0
SEMICN ;
IDENFR i
ASSIGN =
IDENFR i
PLUS +
INTCON 1
SEMICN ;
RBRACE }
RETURNTK return
SEMICN ;
RBRACE }
VOIDTK void
IDENFR copy
LPARENT (
RPARENT )
LBRACE {
INTTK int
IDENFR i
ASSIGN =
INTCON 0
SEMICN ;
WHILETK while
LPARENT (
IDENFR i
LSS <
INTCON 20
RPARENT )
LBRACE {
IDENFR result
LBRACK [
IDENFR i
RBRACK ]
ASSIGN =
IDENFR record
LBRACK [
IDENFR i
RBRACK ]
SEMICN ;
IDENFR i
ASSIGN =
IDENFR i
PLUS +
INTCON 1
SEMICN ;
RBRACE }
RETURNTK return
SEMICN ;
RBRACE }
VOIDTK void
IDENFR attribute
LPARENT (
INTTK int
IDENFR num
COMMA ,
INTTK int
IDENFR groupNum
RPARENT )
LBRACE {
IFTK if
LPARENT (
IDENFR num
GRE >
IDENFR m
RPARENT )
LBRACE {
IFTK if
LPARENT (
IDENFR groupNum
LSS <
IDENFR minGroup
RPARENT )
LBRACE {
IDENFR minGroup
ASSIGN =
IDENFR groupNum
SEMICN ;
IDENFR copy
LPARENT (
RPARENT )
SEMICN ;
RBRACE }
RETURNTK return
SEMICN ;
RBRACE }
INTTK int
IDENFR i
ASSIGN =
INTCON 1
SEMICN ;
WHILETK while
LPARENT (
IDENFR i
LEQ <=
IDENFR groupNum
RPARENT )
LBRACE {
INTTK int
IDENFR flag
ASSIGN =
INTCON 0
SEMICN ;
INTTK int
IDENFR j
ASSIGN =
INTCON 1
SEMICN ;
WHILETK while
LPARENT (
IDENFR j
LEQ <=
IDENFR m
RPARENT )
LBRACE {
IFTK if
LPARENT (
IDENFR conflictMap
LBRACK [
IDENFR num
RBRACK ]
LBRACK [
IDENFR j
RBRACK ]
EQL ==
INTCON 1
AND &&
IDENFR record
LBRACK [
IDENFR j
RBRACK ]
EQL ==
IDENFR i
RPARENT )
LBRACE {
IDENFR flag
ASSIGN =
INTCON 1
SEMICN ;
RBRACE }
IDENFR j
ASSIGN =
IDENFR j
PLUS +
INTCON 1
SEMICN ;
RBRACE }
IFTK if
LPARENT (
IDENFR flag
EQL ==
INTCON 0
RPARENT )
LBRACE {
IDENFR record
LBRACK [
IDENFR num
RBRACK ]
ASSIGN =
IDENFR i
SEMICN ;
IDENFR attribute
LPARENT (
IDENFR num
PLUS +
INTCON 1
COMMA ,
IDENFR groupNum
RPARENT )
SEMICN ;
IDENFR record
LBRACK [
IDENFR num
RBRACK ]
ASSIGN =
INTCON 0
SEMICN ;
RBRACE }
IDENFR i
ASSIGN =
IDENFR i
PLUS +
INTCON 1
SEMICN ;
RBRACE }
IDENFR record
LBRACK [
IDENFR num
RBRACK ]
ASSIGN =
IDENFR groupNum
PLUS +
INTCON 1
SEMICN ;
IDENFR attribute
LPARENT (
IDENFR num
PLUS +
INTCON 1
COMMA ,
IDENFR groupNum
PLUS +
INTCON 1
RPARENT )
SEMICN ;
RETURNTK return
SEMICN ;
RBRACE }
INTTK int
MAINTK main
LPARENT (
RPARENT )
LBRACE {
PRINTFTK printf
LPARENT (
STRCON "20373360\n"
RPARENT )
SEMICN ;
IDENFR init
LPARENT (
RPARENT )
SEMICN ;
INTTK int
IDENFR n
SEMICN ;
IDENFR n
ASSIGN =
GETINTTK getint
LPARENT (
RPARENT )
SEMICN ;
IDENFR m
ASSIGN =
GETINTTK getint
LPARENT (
RPARENT )
SEMICN ;
INTTK int
IDENFR i
ASSIGN =
INTCON 0
SEMICN ;
WHILETK while
LPARENT (
IDENFR i
LSS <
IDENFR n
RPARENT )
LBRACE {
INTTK int
IDENFR j
ASSIGN =
INTCON 0
SEMICN ;
INTTK int
IDENFR temp
LBRACK [
INTCON 3
RBRACK ]
SEMICN ;
WHILETK while
LPARENT (
INTCON 3
RPARENT )
LBRACE {
INTTK int
IDENFR k
SEMICN ;
IDENFR k
ASSIGN =
GETINTTK getint
LPARENT (
RPARENT )
SEMICN ;
IDENFR temp
LBRACK [
IDENFR j
RBRACK ]
ASSIGN =
IDENFR k
SEMICN ;
IFTK if
LPARENT (
IDENFR j
GRE >
INTCON 1
RPARENT )
BREAKTK break
SEMICN ;
ELSETK else
IDENFR j
ASSIGN =
IDENFR j
PLUS +
INTCON 1
SEMICN ;
RBRACE }
IDENFR conflictMap
LBRACK [
IDENFR temp
LBRACK [
INTCON 0
RBRACK ]
RBRACK ]
LBRACK [
IDENFR temp
LBRACK [
INTCON 1
RBRACK ]
RBRACK ]
ASSIGN =
INTCON 1
SEMICN ;
IDENFR conflictMap
LBRACK [
IDENFR temp
LBRACK [
INTCON 1
RBRACK ]
RBRACK ]
LBRACK [
IDENFR temp
LBRACK [
INTCON 0
RBRACK ]
RBRACK ]
ASSIGN =
INTCON 1
SEMICN ;
IDENFR conflictMap
LBRACK [
IDENFR temp
LBRACK [
INTCON 0
RBRACK ]
RBRACK ]
LBRACK [
IDENFR temp
LBRACK [
INTCON 2
RBRACK ]
RBRACK ]
ASSIGN =
INTCON 1
SEMICN ;
IDENFR conflictMap
LBRACK [
IDENFR temp
LBRACK [
INTCON 2
RBRACK ]
RBRACK ]
LBRACK [
IDENFR temp
LBRACK [
INTCON 0
RBRACK ]
RBRACK ]
ASSIGN =
INTCON 1
SEMICN ;
IDENFR conflictMap
LBRACK [
IDENFR temp
LBRACK [
INTCON 1
RBRACK ]
RBRACK ]
LBRACK [
IDENFR temp
LBRACK [
INTCON 2
RBRACK ]
RBRACK ]
ASSIGN =
INTCON 1
SEMICN ;
IDENFR conflictMap
LBRACK [
IDENFR temp
LBRACK [
INTCON 2
RBRACK ]
RBRACK ]
LBRACK [
IDENFR temp
LBRACK [
INTCON 1
RBRACK ]
RBRACK ]
ASSIGN =
INTCON 1
SEMICN ;
IDENFR i
ASSIGN =
IDENFR i
PLUS +
INTCON 1
SEMICN ;
RBRACE }
IDENFR attribute
LPARENT (
INTCON 1
COMMA ,
INTCON 1
RPARENT )
SEMICN ;
PRINTFTK printf
LPARENT (
STRCON "input:\n"
RPARENT )
SEMICN ;
PRINTFTK printf
LPARENT (
STRCON "4\n7\n1 2 3\n2 3 4\n3 4 5\n4 5 6\n"
RPARENT )
SEMICN ;
PRINTFTK printf
LPARENT (
STRCON "Your answer is:\n"
RPARENT )
SEMICN ;
IDENFR i
ASSIGN =
INTCON 1
SEMICN ;
WHILETK while
LPARENT (
IDENFR i
LEQ <=
IDENFR minGroup
RPARENT )
LBRACE {
INTTK int
IDENFR j
ASSIGN =
INTCON 1
SEMICN ;
WHILETK while
LPARENT (
IDENFR j
LEQ <=
IDENFR m
RPARENT )
LBRACE {
IFTK if
LPARENT (
IDENFR result
LBRACK [
IDENFR j
RBRACK ]
EQL ==
IDENFR i
RPARENT )
LBRACE {
PRINTFTK printf
LPARENT (
STRCON "%d"
COMMA ,
IDENFR j
RPARENT )
SEMICN ;
RBRACE }
IDENFR j
ASSIGN =
IDENFR j
PLUS +
INTCON 1
SEMICN ;
RBRACE }
PRINTFTK printf
LPARENT (
STRCON "\n"
RPARENT )
SEMICN ;
IDENFR i
ASSIGN =
IDENFR i
PLUS +
INTCON 1
SEMICN ;
RBRACE }
PRINTFTK printf
LPARENT (
STRCON "expect:\n"
RPARENT )
SEMICN ;
PRINTFTK printf
LPARENT (
STRCON "1 4 7\n2 5\n3 6\n"
RPARENT )
SEMICN ;
IFTK if
LPARENT (
INTCON 0
AND &&
IDENFR func
LPARENT (
RPARENT )
RPARENT )
LBRACE {
RBRACE }
PRINTFTK printf
LPARENT (
STRCON "%d\n"
COMMA ,
IDENFR global_var
RPARENT )
SEMICN ;
IFTK if
LPARENT (
INTCON 1
OR ||
IDENFR func
LPARENT (
RPARENT )
RPARENT )
LBRACE {
RBRACE }
PRINTFTK printf
LPARENT (
STRCON "%d\n"
COMMA ,
IDENFR global_var
RPARENT )
SEMICN ;
RETURNTK return
INTCON 0
SEMICN ;
RBRACE }
