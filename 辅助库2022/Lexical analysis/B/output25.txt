CONSTTK const
INTTK int
IDENFR MAX
ASSIGN =
INTCON 100010
SEMICN ;
INTTK int
IDENFR p
LBRACK [
INTCON 100010
RBRACK ]
SEMICN ;
INTTK int
IDENFR judge_prime
LPARENT (
INTTK int
IDENFR num
COMMA ,
INTTK int
IDENFR prime_count
RPARENT )
LBRACE {
INTTK int
IDENFR i
ASSIGN =
INTCON 1
SEMICN ;
IFTK if
LPARENT (
IDENFR num
NEQ !=
INTCON 2
RPARENT )
LBRACE {
IFTK if
LPARENT (
IDENFR num
MOD %
INTCON 2
EQL ==
INTCON 0
RPARENT )
RETURNTK return
INTCON 0
SEMICN ;
RBRACE }
WHILETK while
LPARENT (
IDENFR i
LSS <
IDENFR prime_count
RPARENT )
LBRACE {
IFTK if
LPARENT (
LPARENT (
IDENFR p
LBRACK [
IDENFR i
RBRACK ]
MULT *
IDENFR p
LBRACK [
IDENFR i
RBRACK ]
RPARENT )
GRE >
IDENFR num
RPARENT )
BREAKTK break
SEMICN ;
IFTK if
LPARENT (
IDENFR num
MOD %
IDENFR p
LBRACK [
IDENFR i
RBRACK ]
NEQ !=
INTCON 0
RPARENT )
LBRACE {
IDENFR i
ASSIGN =
LPARENT (
IDENFR i
PLUS +
INTCON 2
RPARENT )
SEMICN ;
RBRACE }
ELSETK else
LBRACE {
RETURNTK return
INTCON 0
SEMICN ;
RBRACE }
RBRACE }
RETURNTK return
INTCON 1
SEMICN ;
RBRACE }
INTTK int
IDENFR cal_prime
LPARENT (
INTTK int
IDENFR m
RPARENT )
LBRACE {
INTTK int
IDENFR prime_count
ASSIGN =
INTCON 1
SEMICN ;
IFTK if
LPARENT (
IDENFR m
LSS <
INTCON 2
RPARENT )
RETURNTK return
INTCON 0
SEMICN ;
IFTK if
LPARENT (
IDENFR m
EQL ==
INTCON 2
RPARENT )
RETURNTK return
IDENFR prime_count
SEMICN ;
ELSETK else
LBRACE {
INTTK int
IDENFR potential_prime
ASSIGN =
PLUS +
INTCON 3
SEMICN ;
WHILETK while
LPARENT (
IDENFR potential_prime
LEQ <=
IDENFR m
RPARENT )
LBRACE {
IFTK if
LPARENT (
IDENFR judge_prime
LPARENT (
IDENFR potential_prime
COMMA ,
IDENFR prime_count
RPARENT )
RPARENT )
LBRACE {
IDENFR p
LBRACK [
IDENFR prime_count
RBRACK ]
ASSIGN =
IDENFR potential_prime
SEMICN ;
IDENFR prime_count
ASSIGN =
IDENFR prime_count
PLUS +
INTCON 1
SEMICN ;
RBRACE }
IDENFR potential_prime
ASSIGN =
IDENFR potential_prime
PLUS +
INTCON 2
SEMICN ;
IFTK if
LPARENT (
IDENFR prime_count
GRE >
IDENFR MAX
RPARENT )
LBRACE {
PRINTFTK printf
LPARENT (
STRCON "prime count reaches maximum: %d\n"
COMMA ,
IDENFR MAX
RPARENT )
SEMICN ;
BREAKTK break
SEMICN ;
RBRACE }
RBRACE }
RETURNTK return
IDENFR prime_count
SEMICN ;
RBRACE }
RETURNTK return
IDENFR prime_count
SEMICN ;
RBRACE }
VOIDTK void
IDENFR print_prime
LPARENT (
INTTK int
IDENFR upper_bound
RPARENT )
LBRACE {
INTTK int
IDENFR i
ASSIGN =
INTCON 0
SEMICN ;
INTTK int
IDENFR prime_count
SEMICN ;
IDENFR prime_count
ASSIGN =
IDENFR cal_prime
LPARENT (
IDENFR upper_bound
RPARENT )
SEMICN ;
PRINTFTK printf
LPARENT (
STRCON "\nprime_count:%d\n"
COMMA ,
IDENFR prime_count
RPARENT )
SEMICN ;
PRINTFTK printf
LPARENT (
STRCON "prime less or equal than %d are belows:\n"
COMMA ,
IDENFR upper_bound
RPARENT )
SEMICN ;
WHILETK while
LPARENT (
IDENFR i
LSS <
IDENFR prime_count
RPARENT )
LBRACE {
PRINTFTK printf
LPARENT (
STRCON "%d"
COMMA ,
IDENFR p
LBRACK [
IDENFR i
RBRACK ]
RPARENT )
SEMICN ;
IFTK if
LPARENT (
IDENFR i
NEQ !=
IDENFR prime_count
MINU -
INTCON 1
RPARENT )
PRINTFTK printf
LPARENT (
STRCON ", "
RPARENT )
SEMICN ;
ELSETK else
PRINTFTK printf
LPARENT (
STRCON "\n"
RPARENT )
SEMICN ;
IDENFR i
ASSIGN =
IDENFR i
PLUS +
INTCON 1
SEMICN ;
RBRACE }
RETURNTK return
SEMICN ;
RBRACE }
INTTK int
IDENFR prime_div
LPARENT (
INTTK int
IDENFR num
COMMA ,
INTTK int
IDENFR p
LBRACK [
RBRACK ]
RPARENT )
LBRACE {
INTTK int
IDENFR len
ASSIGN =
INTCON 0
COMMA ,
IDENFR i
ASSIGN =
INTCON 2
COMMA ,
IDENFR prime_count
ASSIGN =
INTCON 0
SEMICN ;
IFTK if
LPARENT (
IDENFR num
LSS <
INTCON 2
RPARENT )
RETURNTK return
INTCON 0
SEMICN ;
WHILETK while
LPARENT (
IDENFR i
LEQ <=
IDENFR num
RPARENT )
LBRACE {
WHILETK while
LPARENT (
IDENFR num
MOD %
IDENFR i
EQL ==
INTCON 0
RPARENT )
LBRACE {
IDENFR num
ASSIGN =
IDENFR num
DIV /
IDENFR i
SEMICN ;
IDENFR p
LBRACK [
IDENFR prime_count
RBRACK ]
ASSIGN =
IDENFR i
SEMICN ;
IDENFR prime_count
ASSIGN =
IDENFR prime_count
PLUS +
INTCON 1
SEMICN ;
RBRACE }
IFTK if
LPARENT (
IDENFR i
EQL ==
INTCON 2
RPARENT )
IDENFR i
ASSIGN =
INTCON 3
SEMICN ;
ELSETK else
IDENFR i
ASSIGN =
IDENFR i
PLUS +
INTCON 2
SEMICN ;
IFTK if
LPARENT (
IDENFR i
MULT *
IDENFR i
GRE >
IDENFR num
RPARENT )
LBRACE {
IDENFR p
LBRACK [
IDENFR prime_count
RBRACK ]
ASSIGN =
IDENFR num
SEMICN ;
IDENFR prime_count
ASSIGN =
IDENFR prime_count
PLUS +
INTCON 1
SEMICN ;
BREAKTK break
SEMICN ;
RBRACE }
RBRACE }
RETURNTK return
IDENFR prime_count
SEMICN ;
RBRACE }
VOIDTK void
IDENFR print_prime_div
LPARENT (
INTTK int
IDENFR num
RPARENT )
LBRACE {
INTTK int
IDENFR a
LBRACK [
INTCON 40
RBRACK ]
COMMA ,
IDENFR i
ASSIGN =
INTCON 0
SEMICN ;
INTTK int
IDENFR prime_count
ASSIGN =
IDENFR prime_div
LPARENT (
IDENFR num
COMMA ,
IDENFR a
RPARENT )
SEMICN ;
PRINTFTK printf
LPARENT (
STRCON "\nthe prime division of %d are:\n"
COMMA ,
IDENFR num
RPARENT )
SEMICN ;
WHILETK while
LPARENT (
IDENFR prime_count
GEQ >=
IDENFR i
PLUS +
INTCON 1
RPARENT )
LBRACE {
IFTK if
LPARENT (
IDENFR prime_count
GRE >
IDENFR i
PLUS +
INTCON 1
RPARENT )
LBRACE {
PRINTFTK printf
LPARENT (
STRCON "%d, "
COMMA ,
IDENFR a
LBRACK [
IDENFR i
RBRACK ]
RPARENT )
SEMICN ;
RBRACE }
ELSETK else
LBRACE {
PRINTFTK printf
LPARENT (
STRCON "%d\n"
COMMA ,
IDENFR a
LBRACK [
IDENFR i
RBRACK ]
RPARENT )
SEMICN ;
RBRACE }
IDENFR i
ASSIGN =
IDENFR i
PLUS +
INTCON 1
SEMICN ;
RBRACE }
RETURNTK return
SEMICN ;
RBRACE }
INTTK int
MAINTK main
LPARENT (
RPARENT )
LBRACE {
PRINTFTK printf
LPARENT (
STRCON "20373743\n"
RPARENT )
SEMICN ;
IDENFR p
LBRACK [
INTCON 0
RBRACK ]
ASSIGN =
INTCON 2
SEMICN ;
INTTK int
IDENFR upper_bound
SEMICN ;
IDENFR upper_bound
ASSIGN =
GETINTTK getint
LPARENT (
RPARENT )
SEMICN ;
IDENFR print_prime
LPARENT (
IDENFR upper_bound
RPARENT )
SEMICN ;
IDENFR print_prime
LPARENT (
INTCON 100
RPARENT )
SEMICN ;
INTTK int
IDENFR x
SEMICN ;
IDENFR x
ASSIGN =
GETINTTK getint
LPARENT (
RPARENT )
SEMICN ;
IDENFR print_prime_div
LPARENT (
IDENFR x
RPARENT )
SEMICN ;
IDENFR print_prime_div
LPARENT (
INTCON 1000001
RPARENT )
SEMICN ;
RETURNTK return
INTCON 0
SEMICN ;
RBRACE }
