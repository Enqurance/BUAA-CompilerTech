CONSTTK const
INTTK int
IDENFR SIZE
ASSIGN =
INTCON 1000
SEMICN ;
CONSTTK const
INTTK int
IDENFR qpow_MOD
ASSIGN =
INTCON 10089
SEMICN ;
INTTK int
IDENFR arr
LBRACK [
INTCON 1000
PLUS +
INTCON 2
RBRACK ]
SEMICN ;
INTTK int
IDENFR temp
LBRACK [
INTCON 1000
PLUS +
INTCON 2
RBRACK ]
SEMICN ;
VOIDTK void
IDENFR divide_and_conquer_sort
LPARENT (
INTTK int
IDENFR n
COMMA ,
INTTK int
IDENFR a
LBRACK [
RBRACK ]
COMMA ,
INTTK int
IDENFR s
RPARENT )
LBRACE {
IFTK if
LPARENT (
IDENFR n
EQL ==
INTCON 1
RPARENT )
LBRACE {
RETURNTK return
SEMICN ;
RBRACE }
ELSETK else
IFTK if
LPARENT (
IDENFR n
EQL ==
INTCON 2
RPARENT )
LBRACE {
IFTK if
LPARENT (
IDENFR a
LBRACK [
IDENFR s
PLUS +
INTCON 0
RBRACK ]
GRE >
IDENFR a
LBRACK [
IDENFR s
PLUS +
INTCON 1
RBRACK ]
RPARENT )
LBRACE {
INTTK int
IDENFR tmp
ASSIGN =
IDENFR a
LBRACK [
IDENFR s
PLUS +
INTCON 0
RBRACK ]
SEMICN ;
IDENFR a
LBRACK [
IDENFR s
PLUS +
INTCON 0
RBRACK ]
ASSIGN =
IDENFR a
LBRACK [
IDENFR s
PLUS +
INTCON 1
RBRACK ]
SEMICN ;
IDENFR a
LBRACK [
IDENFR s
PLUS +
INTCON 1
RBRACK ]
ASSIGN =
IDENFR tmp
SEMICN ;
RBRACE }
RBRACE }
ELSETK else
LBRACE {
INTTK int
IDENFR first_n
ASSIGN =
IDENFR n
DIV /
INTCON 2
SEMICN ;
INTTK int
IDENFR last_n
ASSIGN =
IDENFR n
MINU -
IDENFR first_n
SEMICN ;
IDENFR divide_and_conquer_sort
LPARENT (
IDENFR first_n
COMMA ,
IDENFR a
COMMA ,
IDENFR s
RPARENT )
SEMICN ;
IDENFR divide_and_conquer_sort
LPARENT (
IDENFR last_n
COMMA ,
IDENFR a
COMMA ,
IDENFR s
PLUS +
IDENFR first_n
RPARENT )
SEMICN ;
INTTK int
IDENFR tpos
ASSIGN =
INTCON 0
SEMICN ;
INTTK int
IDENFR f_pos
ASSIGN =
INTCON 0
SEMICN ;
INTTK int
IDENFR l_pos
ASSIGN =
INTCON 0
SEMICN ;
INTTK int
IDENFR last_s
ASSIGN =
IDENFR s
PLUS +
IDENFR first_n
SEMICN ;
WHILETK while
LPARENT (
INTCON 1
RPARENT )
LBRACE {
IFTK if
LPARENT (
IDENFR f_pos
EQL ==
IDENFR first_n
MINU -
INTCON 1
RPARENT )
LBRACE {
IFTK if
LPARENT (
IDENFR l_pos
EQL ==
IDENFR last_n
MINU -
INTCON 1
RPARENT )
LBRACE {
BREAKTK break
SEMICN ;
RBRACE }
RBRACE }
IFTK if
LPARENT (
IDENFR f_pos
EQL ==
IDENFR first_n
MINU -
INTCON 1
RPARENT )
LBRACE {
IDENFR temp
LBRACK [
IDENFR tpos
RBRACK ]
ASSIGN =
IDENFR a
LBRACK [
IDENFR last_s
PLUS +
IDENFR l_pos
RBRACK ]
SEMICN ;
IDENFR tpos
ASSIGN =
IDENFR tpos
PLUS +
INTCON 1
SEMICN ;
IDENFR l_pos
ASSIGN =
IDENFR l_pos
PLUS +
INTCON 1
SEMICN ;
RBRACE }
ELSETK else
IFTK if
LPARENT (
IDENFR l_pos
EQL ==
IDENFR last_n
MINU -
INTCON 1
RPARENT )
LBRACE {
IDENFR temp
LBRACK [
IDENFR tpos
RBRACK ]
ASSIGN =
IDENFR a
LBRACK [
IDENFR s
PLUS +
IDENFR f_pos
RBRACK ]
SEMICN ;
IDENFR tpos
ASSIGN =
IDENFR tpos
PLUS +
INTCON 1
SEMICN ;
IDENFR f_pos
ASSIGN =
IDENFR f_pos
PLUS +
INTCON 1
SEMICN ;
RBRACE }
ELSETK else
LBRACE {
IFTK if
LPARENT (
IDENFR a
LBRACK [
IDENFR s
PLUS +
IDENFR f_pos
RBRACK ]
LSS <
IDENFR a
LBRACK [
IDENFR last_s
PLUS +
IDENFR l_pos
RBRACK ]
RPARENT )
LBRACE {
IDENFR temp
LBRACK [
IDENFR tpos
RBRACK ]
ASSIGN =
IDENFR a
LBRACK [
IDENFR s
PLUS +
IDENFR f_pos
RBRACK ]
SEMICN ;
IDENFR tpos
ASSIGN =
IDENFR tpos
PLUS +
INTCON 1
SEMICN ;
IDENFR f_pos
ASSIGN =
IDENFR f_pos
PLUS +
INTCON 1
SEMICN ;
RBRACE }
ELSETK else
LBRACE {
IDENFR temp
LBRACK [
IDENFR tpos
RBRACK ]
ASSIGN =
IDENFR a
LBRACK [
IDENFR last_s
PLUS +
IDENFR l_pos
RBRACK ]
SEMICN ;
IDENFR tpos
ASSIGN =
IDENFR tpos
PLUS +
INTCON 1
SEMICN ;
IDENFR l_pos
ASSIGN =
IDENFR l_pos
PLUS +
INTCON 1
SEMICN ;
RBRACE }
RBRACE }
RBRACE }
INTTK int
IDENFR i
ASSIGN =
INTCON 0
SEMICN ;
WHILETK while
LPARENT (
IDENFR i
NEQ !=
IDENFR n
RPARENT )
LBRACE {
IDENFR a
LBRACK [
IDENFR s
PLUS +
IDENFR i
RBRACK ]
ASSIGN =
IDENFR temp
LBRACK [
IDENFR i
RBRACK ]
SEMICN ;
IDENFR i
ASSIGN =
IDENFR i
PLUS +
INTCON 1
SEMICN ;
RBRACE }
RBRACE }
RETURNTK return
SEMICN ;
RBRACE }
INTTK int
IDENFR quick_pow
LPARENT (
INTTK int
IDENFR a
COMMA ,
INTTK int
IDENFR p
COMMA ,
INTTK int
IDENFR mod
RPARENT )
LBRACE {
INTTK int
IDENFR pp
ASSIGN =
IDENFR p
SEMICN ;
INTTK int
IDENFR A
ASSIGN =
IDENFR a
SEMICN ;
INTTK int
IDENFR ans
ASSIGN =
INTCON 1
SEMICN ;
WHILETK while
LPARENT (
IDENFR pp
NEQ !=
INTCON 0
RPARENT )
LBRACE {
IFTK if
LPARENT (
IDENFR pp
MOD %
INTCON 2
EQL ==
INTCON 1
RPARENT )
LBRACE {
IDENFR ans
ASSIGN =
IDENFR ans
MULT *
IDENFR A
MOD %
IDENFR mod
SEMICN ;
RBRACE }
IDENFR A
ASSIGN =
IDENFR A
MULT *
IDENFR A
MOD %
IDENFR mod
SEMICN ;
IDENFR pp
ASSIGN =
IDENFR pp
DIV /
INTCON 2
SEMICN ;
RBRACE }
RETURNTK return
IDENFR ans
SEMICN ;
RBRACE }
INTTK int
IDENFR hash
LPARENT (
INTTK int
IDENFR n
COMMA ,
INTTK int
IDENFR a
LBRACK [
RBRACK ]
RPARENT )
LBRACE {
CONSTTK const
INTTK int
IDENFR Base
ASSIGN =
INTCON 53
SEMICN ;
CONSTTK const
INTTK int
IDENFR MOD
ASSIGN =
INTCON 9999973
SEMICN ;
INTTK int
IDENFR hash
ASSIGN =
INTCON 0
SEMICN ;
INTTK int
IDENFR i
ASSIGN =
INTCON 0
SEMICN ;
WHILETK while
LPARENT (
IDENFR i
NEQ !=
IDENFR n
RPARENT )
LBRACE {
IDENFR hash
ASSIGN =
LPARENT (
IDENFR hash
MULT *
IDENFR Base
PLUS +
IDENFR a
LBRACK [
IDENFR i
RBRACK ]
RPARENT )
MOD %
IDENFR MOD
SEMICN ;
IDENFR i
ASSIGN =
IDENFR i
PLUS +
INTCON 1
SEMICN ;
RBRACE }
RETURNTK return
IDENFR hash
SEMICN ;
RBRACE }
INTTK int
MAINTK main
LPARENT (
RPARENT )
LBRACE {
PRINTFTK printf
LPARENT (
STRCON "20373649\n"
RPARENT )
SEMICN ;
INTTK int
IDENFR cnt
ASSIGN =
INTCON 0
SEMICN ;
WHILETK while
LPARENT (
IDENFR cnt
NEQ !=
INTCON 5
RPARENT )
LBRACE {
INTTK int
IDENFR n
SEMICN ;
IDENFR n
ASSIGN =
GETINTTK getint
LPARENT (
RPARENT )
SEMICN ;
INTTK int
IDENFR i
ASSIGN =
INTCON 0
SEMICN ;
WHILETK while
LPARENT (
IDENFR i
NEQ !=
IDENFR n
RPARENT )
LBRACE {
IDENFR arr
LBRACK [
IDENFR i
RBRACK ]
ASSIGN =
GETINTTK getint
LPARENT (
RPARENT )
SEMICN ;
IDENFR i
ASSIGN =
IDENFR i
PLUS +
INTCON 1
SEMICN ;
RBRACE }
IDENFR divide_and_conquer_sort
LPARENT (
IDENFR n
COMMA ,
IDENFR arr
COMMA ,
INTCON 0
RPARENT )
SEMICN ;
PRINTFTK printf
LPARENT (
STRCON "The hash of the sorted array is %d.\n"
COMMA ,
IDENFR hash
LPARENT (
IDENFR n
COMMA ,
IDENFR arr
RPARENT )
RPARENT )
SEMICN ;
IDENFR cnt
ASSIGN =
IDENFR cnt
PLUS +
INTCON 1
SEMICN ;
RBRACE }
INTTK int
IDENFR qpow_ans
LBRACK [
INTCON 4
RBRACK ]
SEMICN ;
IDENFR qpow_ans
LBRACK [
INTCON 0
RBRACK ]
ASSIGN =
IDENFR quick_pow
LPARENT (
INTCON 34
COMMA ,
INTCON 89
COMMA ,
IDENFR qpow_MOD
RPARENT )
SEMICN ;
IDENFR qpow_ans
LBRACK [
INTCON 1
RBRACK ]
ASSIGN =
IDENFR quick_pow
LPARENT (
INTCON 59
COMMA ,
INTCON 122
COMMA ,
IDENFR qpow_MOD
RPARENT )
SEMICN ;
IDENFR qpow_ans
LBRACK [
INTCON 2
RBRACK ]
ASSIGN =
IDENFR quick_pow
LPARENT (
INTCON 13
COMMA ,
INTCON 3444
COMMA ,
IDENFR qpow_MOD
RPARENT )
SEMICN ;
IDENFR qpow_ans
LBRACK [
INTCON 3
RBRACK ]
ASSIGN =
IDENFR quick_pow
LPARENT (
INTCON 11
COMMA ,
INTCON 987
COMMA ,
IDENFR qpow_MOD
RPARENT )
SEMICN ;
PRINTFTK printf
LPARENT (
STRCON "The answer of quick_pow is: %d %d %d %d.\n"
COMMA ,
IDENFR qpow_ans
LBRACK [
INTCON 0
RBRACK ]
COMMA ,
IDENFR qpow_ans
LBRACK [
INTCON 1
RBRACK ]
COMMA ,
IDENFR qpow_ans
LBRACK [
INTCON 2
RBRACK ]
COMMA ,
IDENFR qpow_ans
LBRACK [
INTCON 3
RBRACK ]
RPARENT )
SEMICN ;
INTTK int
IDENFR a
SEMICN ;
IDENFR a
ASSIGN =
GETINTTK getint
LPARENT (
RPARENT )
SEMICN ;
INTTK int
IDENFR b
SEMICN ;
IDENFR b
ASSIGN =
GETINTTK getint
LPARENT (
RPARENT )
SEMICN ;
INTTK int
IDENFR c
SEMICN ;
IDENFR c
ASSIGN =
GETINTTK getint
LPARENT (
RPARENT )
SEMICN ;
IFTK if
LPARENT (
IDENFR a
LSS <
IDENFR b
EQL ==
IDENFR b
LSS <
IDENFR c
RPARENT )
LBRACE {
PRINTFTK printf
LPARENT (
STRCON "a < b and b < c are equal.\n"
RPARENT )
SEMICN ;
RBRACE }
LBRACE {
LBRACE {
LBRACE {
LBRACE {
LBRACE {
RBRACE }
RBRACE }
RBRACE }
RBRACE }
RBRACE }
INTCON 213
MULT *
INTCON 789
SEMICN ;
INTCON 2334
MINU -
INTCON 2378
SEMICN ;
INTTK int
IDENFR tmp_val
SEMICN ;
IDENFR tmp_val
ASSIGN =
GETINTTK getint
LPARENT (
RPARENT )
SEMICN ;
IDENFR tmp_val
ASSIGN =
IDENFR tmp_val
MULT *
INTCON 8
MULT *
INTCON 16
MULT *
INTCON 256
SEMICN ;
PRINTFTK printf
LPARENT (
STRCON "The num I input is: %d\n"
COMMA ,
IDENFR tmp_val
DIV /
INTCON 8
DIV /
INTCON 16
DIV /
INTCON 256
RPARENT )
SEMICN ;
INTTK int
IDENFR d
ASSIGN =
LPARENT (
LPARENT (
INTCON 12
MULT *
IDENFR tmp_val
RPARENT )
DIV /
INTCON 7
MULT *
INTCON 23
MINU -
INTCON 2222
PLUS +
INTCON 34
RPARENT )
MOD %
INTCON 6
MULT *
INTCON 999
MINU -
INTCON 1222
SEMICN ;
PRINTFTK printf
LPARENT (
STRCON "After a complex calculation: d = %d\n"
COMMA ,
IDENFR d
RPARENT )
SEMICN ;
RETURNTK return
INTCON 0
SEMICN ;
RBRACE }
